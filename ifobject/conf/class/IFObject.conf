# ==========================================================================
# Ionflux Object Base System
# Copyright Â© 2006-2013 Joern P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# IFObject.conf          Class definition file
# ==========================================================================
# 
# This file is part of Ionflux Object Base System.
# 
# Ionflux Object Base System is free software; you can redistribute it 
# and/or modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation; either version 2 of the 
# License, or (at  your option) any later version.
# 
# Ionflux Object Base System is distributed in the hope that it will be 
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Object Base System; if not, write to the Free 
# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	header = {
		'<string>'
		'<vector>'
		'<set>'
		'<map>'
		'<iostream>'
		'"sigc++/connection.h"'
		'"ifobject/serialize.hpp"'
		'"ifobject/log.hpp"'
		'"ifobject/utf8.hpp"'
		'"libb64.hpp"'
		'"ifobject/IFClassInfo.hpp"'
	}
	impl = {
        '<climits>'
        '<cstdlib>'
		'<sstream>'
		'<fstream>'
		'"ifobject/IFError.hpp"'
		'"ifobject/IFMMEvent.hpp"'
		'"ifobject/IFMMEventHandler.hpp"'
		'"ifobject/xmlutils.hpp"'
		'"ifobject/xmlutils_private.hpp"'
		'"ifobject/IFXMLObjectFactory.hpp"'
	}
}

## Undefine macros.
#undef.header = {
#	'assert'
#}

# Forward declarations.
forward = {
	'class IFMutex'
	'class IFMMEvent'
	'class IFMMEventHandler'
}

# Typedefs.

# Helper structs.
struct[] = {
	name = IFObjectRefInfo
	desc = Object reference information
	field[] = {
		type = unsigned int
		name = refCount
		desc = Reference count
	}
}
struct[] = {
	name = IFRefCountData
	desc = Reference counting data
	field[] = {
		type = IFObjectRefMap
		name = refMap
		desc = Local reference map
	}
	field[] = {
		type = unsigned int
		name = refCount
		desc = Reference count
	}
	field[] = {
		type = bool
		name = mmDebug
		desc = memory management debugging flag
	}
}

# events
event[] = {
	id = object
	# using directives
	using = {
		'namespace std'
	}
	# include files.
	include = {
	   header = {
			'"ifobject/types.hpp"'
			'"ifobject/IFObject.hpp"'
	   }
	}
	# forward declarations
	forward = {
	 	'class IFObject'
	}
	# default constructor
	constructor.default = {
		initializer[] = {
			name = type
			value = TYPE_OBJECT_CHANGED
		}
		initializer[] = {
			name = source
			value = 0
		}
		initializer[] = {
			name = oldIDNum
			value = 0
		}
		initializer[] = {
			name = newIDNum
			value = 0
		}
		initializer[] = {
			name = oldID
			value = ""
		}
		initializer[] = {
			name = newID
			value = ""
		}
	}
	# constants
	constant.public[] = {
		name = TYPE_OBJECT_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: object changed
		value = 0
	}
	constant.public[] = {
		name = TYPE_OBJECT_ID_NUM_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: ID number changed
		value = 1
	}
	constant.public[] = {
		name = TYPE_OBJECT_ID_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: ID changed
		value = 2
	}
	# properties (protected)
	property.protected[] = {
		type = Ionflux::ObjectBase::IFEventType
		setFromType = Ionflux::ObjectBase::IFEventType
		name = type
		desc = event type
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObject*
		setFromType = Ionflux::ObjectBase::IFObject*
		name = source
		desc = event source
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFIDNum
		setFromType = Ionflux::ObjectBase::IFIDNum
		name = oldIDNum
		desc = old ID number
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFIDNum
		setFromType = Ionflux::ObjectBase::IFIDNum
		name = newIDNum
		desc = new ID number
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObjectID
		setFromType = const Ionflux::ObjectBase::IFObjectID&
		name = oldID
		desc = old ID
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObjectID
		setFromType = const Ionflux::ObjectBase::IFObjectID&
		name = newID
		desc = new ID
	}
}

# signals
signal[] = {
	id = object
	return.type = bool
	param[].type = const Ionflux::ObjectBase::IFObjectEvent&
	instance[] = {
		name = objectChanged
		desc = object changed signal
		id = object_changed
	}
	instance[] = {
		name = objectIDNumChanged
		desc = object ID number changed signal
		id = object_id_num_changed
	}
	instance[] = {
		name = objectIDChanged
		desc = object ID changed signal
		id = object_id_changed
	}
}

# Class definition.
class = {
	name = IFObject
	shortDesc = Object
	title = Object
	longDesc = Base class for all objects.
	group.name = ifobject
	group.shortDesc = Ionflux Object Base System
	group.longDesc = Classes implementing the core functionality of the Ionflux Object Base System.
	features = {
		'mutex'
		'logmessage'
		'serialize'
	}
}

# Public constructors.
constructor.default = {
	initializer[] = {
		name = idNum
		value = ID_NUM_UNDEFINED
	}
	initializer[] = {
		name = refData
		value = 0
	}
	initializer[] = {
		name = guardMutex
		value = 0
	}
	initializer[] = {
		name = logTarget
		value = 0
	}
	impl = /* NOTE: Creating IFObjects here will cause an infinite loop. \
         (Don't do it.) */\
refData = new IFRefCountData();\
if (refData == 0)\
\{\
	std::cerr << "[IFObject::IFObject] ERROR: "\
		"Could not allocate reference count data structure "\
		"(this is bad, exiting)." << std::endl;\
	exit(-1);\
\}\
refData->refCount = 0;\
refData->mmDebug = false;
}

# Destructor.
destructor.impl = <<<
removeAllLocalRefs();
/* <---- DEBUG ----- //
std::cerr << "[IFObject::~IFObject] DEBUG: "
    "Deleting refData " << refData << std::endl;
// ----- DEBUG ----> */
delete refData;
refData = 0;
>>>

# public constants
constant.public[] = {
	name = LITERAL_PREFIX
	type = std::string
	desc = object literal prefix
	value = "%%"
}
constant.public[] = {
	name = LITERAL_SEPARATOR
	type = std::string
	desc = object literal separator
	value = ":"
}
constant.public[] = {
	name = ENCODING_RAW
	type = std::string
	desc = encoding: raw
	value = "raw"
}
constant.public[] = {
	name = ENCODING_UTF8
	type = std::string
	desc = encoding: UTF-8
	value = "utf8"
}
constant.public[] = {
	name = ENCODING_BASE64
	type = std::string
	desc = encoding: base64
	value = "base64"
}
constant.public[] = {
	name = DEFAULT_SIZE
	type = Ionflux::ObjectBase::UInt64
	desc = Default object size
	value = 1
}
constant.public[] = {
	type = std::string
	name = XML_ELEMENT_NAME
	desc = XML element name
	value = "object"
}

# Protected variables.
variable.protected[] = {
	name = theClass
	type = const Ionflux::ObjectBase::IFClassInfo*
	desc = Class info
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFObjectID
	name = id
	desc = Object ID
	serialize = true
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFIDNum
	name = idNum
	desc = ID number
	serialize = true
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFRefCountData*
	name = refData
	desc = Reference counting data
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFMutex*
	name = guardMutex
	desc = Guard mutex
}

# Class properties.
property.protected[] = {
	type = Ionflux::ObjectBase::IFObject*
	setFromType = Ionflux::ObjectBase::IFObject*
	name = logTarget
	desc = Log target
	#managed = true
}

# Public static constants.
constant.public[] = {
	type = IFIDNum
	name = ID_NUM_UNDEFINED
	desc = ID number: undefined
	value = -1
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.public[] = {
	spec = virtual
	type = const Ionflux::ObjectBase::IFClassInfo*
	name = getClass
	const = true
	shortDesc = Get class information
	longDesc = Get the class information.
	return = {
		value = theClass
		desc = The class information, or 0 if no class information exists for this class
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getClassName
	const = true
	shortDesc = Get class name
	longDesc = Get the class name
	impl = const IFClassInfo* theClassInfo = getClass();\
if (theClassInfo != 0)\
	return theClassInfo->getName();
	return = {
		value = ""
		desc = The class name
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getClassDesc
	const = true
	shortDesc = Get class description
	longDesc = Get the class description
	impl = const IFClassInfo* theClassInfo = getClass();\
if (theClassInfo != 0)\
	return theClassInfo->getDesc();
	return = {
		value = ""
		desc = The class description
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = setID
	shortDesc = Set object ID
	longDesc = Set the object ID
	param[] = {
		type = const Ionflux::ObjectBase::IFObjectID&
		name = newID
		desc = Object ID
	}
	impl = IFObjectEvent* event = createObjectEvent();\
event->setType(IFObjectEvent::TYPE_OBJECT_ID_CHANGED);\
event->setSource(this);\
event->setOldID(id);\
event->setNewID(newID);\
id = newID;\
signalObjectIDChanged.emit(*event);\
removeLocalRef(event);
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFObjectID
	name = getID
	const = true
	shortDesc = Get object ID
	longDesc = Get the object ID
	return.value = id
	return.desc = The object ID
}
function.public[] = {
	spec = virtual
	type = void
	name = setIDNum
	shortDesc = Set ID number
	longDesc = Set the ID number
	param[] = {
		type = Ionflux::ObjectBase::IFIDNum
		name = newIDNum
		desc = ID number
	}
	impl = IFObjectEvent* event = createObjectEvent();\
event->setType(IFObjectEvent::TYPE_OBJECT_ID_NUM_CHANGED);\
event->setSource(this);\
event->setOldIDNum(idNum);\
event->setNewIDNum(newIDNum);\
idNum = newIDNum;\
signalObjectIDNumChanged.emit(*event);\
removeLocalRef(event);
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFIDNum
	name = getIDNum
	const = true
	shortDesc = Get ID number
	longDesc = Get the ID number
	return.value = idNum
	return.desc = The ID number
}
function.public[] = {
	spec = virtual
	name = operator std::string
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	return = {
		value = getString()
		desc = String representation of the object
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = getLiteral
	const = true
	shortDesc = Get literal representation
	longDesc = Get a literal representation of the object. This is a string representation which contains the persistent state of the object, so it may be used to restore the state to an unititialized object. It also identifies the type of object which the literal represents.
	param[] = {
		type = std::string&
		name = target
		desc = where to store the literal
	}
	param[] = {
		type = const std::string&
		name = encoding
		desc = encoding to be used
		default = ENCODING_UTF8
	}
	impl = ostringstream state;\
state << LITERAL_PREFIX << getClassName() << LITERAL_SEPARATOR;\
std::string buffer;\
serialize(buffer);\
std::string encoded;\
if (encoding == ENCODING_UTF8)\
\{\
	state << ENCODING_UTF8 << LITERAL_SEPARATOR;\
	for (unsigned int i = 0; i < buffer.size(); i++)\
	\{\
		IFUniChar currentChar = static_cast<IFUniChar>(\
		    static_cast<unsigned char>(buffer[i]));\
		encoded.append(uniCharToUTF8(currentChar));\
	\}\
\} else\
if (encoding == ENCODING_BASE64)\
\{\
	state << ENCODING_UTF8 << LITERAL_SEPARATOR;\
	base64::encode(buffer, encoded);\
\} else\
\{\
	state << ENCODING_RAW << LITERAL_SEPARATOR;\
	encoded = buffer;\
\}\
UInt32 encodedSize = encoded.size();\
state << encodedSize << LITERAL_SEPARATOR \
	<< encoded;\
target = state.str();
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getLiteral2
	const = true
	shortDesc = Get literal representation
	longDesc = Get a literal representation of the object. This is a string representation which contains the persistent state of the object, so it may be used to restore the state to an unititialized object. It also identifies the type of object which the literal represents.
	param[] = {
		type = const std::string&
		name = encoding
		desc = encoding to be used
		default = ENCODING_UTF8
	}
	impl = std::string result;\
getLiteral(result, encoding);
	return = {
	    value = result
	    desc = Object literal
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = initFromLiteral
	shortDesc = Initialize from literal representation
	longDesc = Initialize the object from a literal representation. The object must be an instance of the class or a class derived from the class specified in the literal for this to work.
	param[] = {
		type = const std::string&
		name = source
		desc = literal representation of an object
	}
	impl = DataSize pos = 0;\
ostringstream status;\
// check prefix\
if (source.size() < LITERAL_PREFIX.size())\
\{\
	status << "Literal prefix is missing (literal: '" << source \
		<< "').";\
	log(IFLogMessage(status.str(), VL_ERROR, this, "initFromLiteral"));\
	return false;\
\}\
std::string sourcePrefix = source.substr(0, LITERAL_PREFIX.size());\
if (sourcePrefix != LITERAL_PREFIX)\
\{\
	status << "Literal prefix not found (found: '" << sourcePrefix \
		<< "', expected: '" << LITERAL_PREFIX << "').";\
	log(IFLogMessage(status.str(), VL_ERROR, this, "initFromLiteral"));\
	return false;\
\}\
pos += LITERAL_PREFIX.size();\
// parse literal\
std::string className;\
std::string encoding;\
std::string rawEncodedSize;\
std::string encodedData;\
DataSize encodedSize = 0;\
std::string parseError;\
/* state:\
	0 - extract class name\
	1 - extract encoding\
	2 - extract encoded size\
	3 - extract encoded data\
   -1 - parse error\
   -2 - finished (correct data)\
   -3 - finished (class mismatch)\
 */\
int state = 0;\
unsigned char currentChar = 0;\
while ((state >= 0)\
	&& (pos < source.size()))\
\{\
	currentChar = source[pos];\
	if (state == 0)\
	\{\
		// extract class name\
		if (currentChar == LITERAL_SEPARATOR[0])\
		\{\
			if ((className != theClass->getName())\
				&& (!theClass->isDerivedFrom(className)))\
				state = -3;\
			else\
				state = 1;\
		\} else\
		if (((currentChar >= 'A') \
				&& (currentChar <= 'Z'))\
			|| ((currentChar >= 'a') \
				&& (currentChar <= 'z'))\
			|| ((currentChar >= '0') \
				&& (currentChar <= '9'))\
			|| (currentChar == '_'))\
			className.append(1, currentChar);\
		else\
		\{\
			parseError = "invalid character in class name";\
			state = -1;\
		\}\
	\} else\
	if (state == 1)\
	\{\
		// extract encoding\
		if (currentChar == LITERAL_SEPARATOR[0])\
			state = 2;\
		else\
		if (((currentChar >= 'a') \
				&& (currentChar <= 'z'))\
			|| ((currentChar >= '0') \
				&& (currentChar <= '9'))\
			|| (currentChar == '_'))\
			encoding.append(1, currentChar);\
		else\
		\{\
			parseError = "invalid character in encoding";\
			state = -1;\
		\}\
	\} else\
	if (state == 2)\
	\{\
		// extract encoded size\
		if (currentChar == LITERAL_SEPARATOR[0])\
		\{\
			encodedSize = strtol(rawEncodedSize.c_str(), 0, 10);\
			state = 3;\
		\} else\
		if ((currentChar >= '0') \
				&& (currentChar <= '9'))\
			rawEncodedSize.append(1, currentChar);\
		else\
		\{\
			parseError = "invalid character in encoded size";\
			state = -1;\
		\}\
	\} else\
	if (state == 3)\
	\{\
		// extract encoded data\
		if (encodedData.size() < encodedSize)\
			encodedData.append(1, currentChar);\
		else\
			state = -2;\
	\}\
	pos++;\
\}\
// check for errors\
if (state == -1)\
\{\
	status << "Parse error: " << parseError << " ('" \
		<< currentChar << "' at position " << pos \
		<< " in literal '";\
	if (source.size() > 512)\
		status << source.substr(0, 512) << "...";\
	else\
		status << source;\
	status << "').";\
	log(IFLogMessage(status.str(), VL_ERROR, this, "initFromLiteral"));\
	return false;\
\}\
if (state == -3)\
\{\
	status << "Not a literal of class " << theClass->getName() \
		<< " (literal: '";\
	if (source.size() > 512)\
		status << source.substr(0, 512) << "...";\
	else\
		status << source;\
	status << "').";\
	log(IFLogMessage(status.str(), VL_WARNING_OPT, this, \
		"initFromLiteral"));\
	return false;\
\}\
// verify size of encoded data\
if (encodedData.size() != encodedSize)\
\{\
	status << "Size mismatch for encoded data (extracted: " \
		<< encodedData.size() << " bytes, expected: " \
		<< encodedSize << " bytes, literal: '";\
	if (source.size() > 512)\
		status << source.substr(0, 512) << "...";\
	else\
		status << source;\
	status << "').";\
	log(IFLogMessage(status.str(), VL_WARNING_OPT, this, \
		"initFromLiteral"));\
	return false;\
\}\
// decode data\
std::string decodedData;\
if (encoding == ENCODING_RAW)\
	decodedData = encodedData;\
else\
if (encoding == ENCODING_UTF8)\
\{\
	std::vector<IFUniChar> decodeTemp;\
	if (!utf8ToUniChar(encodedData, decodeTemp))\
	\{\
		status << "Error while decoding UTF-8 data (literal: '";\
		if (source.size() > 512)\
			status << source.substr(0, 512) << "...";\
		else\
			status << source;\
		status << "').";\
		log(IFLogMessage(status.str(), VL_ERROR, this, \
			"initFromLiteral"));\
		return false;\
	\}\
	for (DataSize i = 0; i < decodeTemp.size(); i++)\
	\{\
		if (decodeTemp[i] > 0xff)\
		\{\
			status << "Invalid byte value " << decodeTemp[i] \
				<< " (literal: '";\
			if (source.size() > 512)\
				status << source.substr(0, 512) << "...";\
			else\
				status << source;\
			status << "').";\
			log(IFLogMessage(status.str(), VL_ERROR, this, \
				"initFromLiteral"));\
			return false;\
		\}\
		decodedData.append(1, static_cast<unsigned char>(decodeTemp[i]));\
	\}\
\} else\
if (encoding == ENCODING_BASE64)\
\{\
	if (!base64::decode(encodedData, decodedData))\
	\{\
		status << "Error while decoding base64 data (literal: '";\
		if (source.size() > 512)\
			status << source.substr(0, 512) << "...";\
		else\
			status << source;\
		status << "').";\
		log(IFLogMessage(status.str(), VL_ERROR, this, \
			"initFromLiteral"));\
		return false;\
	\}\
\} else\
\{\
	status << "Unknown encoding '" << encoding \
		<< "' (literal: '";\
	if (source.size() > 512)\
		status << source.substr(0, 512) << "...";\
	else\
		status << source;\
	status << "').";\
	log(IFLogMessage(status.str(), VL_ERROR, this, \
		"initFromLiteral"));\
	return false;\
\}\
// deserialize the object\
if (deserialize(decodedData) == DATA_SIZE_INVALID)\
\{\
	status << "Deserialization failed (literal: '";\
	if (source.size() > 512)\
		status << source.substr(0, 512) << "...";\
	else\
		status << source;\
	status << "').";\
	log(IFLogMessage(status.str(), VL_ERROR, this, \
		"initFromLiteral"));\
	return false;\
\}
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFObject*
	name = copy
	const = true
	shortDesc = Copy
	longDesc = Create a copy of the object.
	impl = log(IFLogMessage("Copy operation not implemented.", \
	VL_ERROR, this, "copy"));
	return = {
		value = 0
		desc = Copy of the object
	}
}
function.public[] = {
	spec = static
	type = Ionflux::ObjectBase::IFObject*
	name = create
	shortDesc = Create instance
	longDesc = Create a new instance of the class. If the optional parent object is specified, a local reference for the new object will be added to the parent object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = parentObject
		desc = Parent object
		default = 0
	}
	impl = IFObject* newObject = new IFObject();\
if (newObject == 0)\
\{\
	cerr << IFLogMessage("Could not allocate object instance.", \
		VL_ERROR, 0, "IFObject::create") << endl;\
	return 0;\
\}\
if (parentObject != 0)\
	parentObject->addLocalRef(newObject);
	return = {
		value = newObject
		desc = Pointer to the new instance, or 0 if an error occurs
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = doOp
	shortDesc = Perform operation
	longDesc = Perform an operation on the object. This provides a very general mechanism to let the object perform an operation. Other objects may be passed for use in the operation in the parameter vector. Results are stored in the target vector, if it is specified. The operation is identified by a name (a string, usually).
	param[] = {
		type = const Ionflux::ObjectBase::IFOpName&
		name = opName
		desc = Operation name
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObjectVector*
		name = params
		desc = Parameters
		default = 0
	}
	param[] = {
		type = Ionflux::ObjectBase::IFObjectVector*
		name = target
		desc = Where to store the result
		default = 0
	}
	impl = opDispatch(opName, params, target);
	return = {
		value = false
		desc = \c true if the operation succeded, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = doOp
	const = true
	shortDesc = Perform operation
	longDesc = Perform an operation on the object. This provides a very general mechanism to let the object perform an operation. Other objects may be passed for use in the operation in the parameter vector. Results are stored in the target vector, if it is specified. The operation is identified by a name (a string, usually).
	param[] = {
		type = const Ionflux::ObjectBase::IFOpName&
		name = opName
		desc = Operation name
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObjectVector*
		name = params
		desc = Parameters
		default = 0
	}
	param[] = {
		type = Ionflux::ObjectBase::IFObjectVector*
		name = target
		desc = Where to store the result
		default = 0
	}
	impl = 
	return = {
		value = opDispatch(opName, params, target);
		desc = \c true if the operation succeded, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFObject&
	name = operator=
	shortDesc = Assignment operator
	longDesc = Assignment operator.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = otherObject
		desc = Object
	}
	impl = log(IFLogMessage("Assignment operator not implemented.", \
	VL_WARNING, this, "operator="));
	return = {
		value = *this
		desc = The object itself
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	shortDesc = Log object
	longDesc = Log an object. If no log target has been set, the default implementation just writes the string representation of the object to standard output. If a log target has been set, the log() function of the target will be called.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (logTarget == 0)\
	cout << logObject << endl;\
else\
	logTarget->log(logObject);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	shortDesc = Log object
	longDesc = Causes the object to log itself.
	impl = log(*this);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	const = true
	shortDesc = Log object
	longDesc = Log an object. If no log target has been set, the default implementation just writes the string representation of the object to standard output. If a log target has been set, the log() function of the target will be called.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (logTarget == 0)\
	cout << logObject << endl;\
else\
	logTarget->log(logObject);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	const = true
	shortDesc = Log object
	longDesc = Causes the object to log itself.
	impl = log(*this);
}
function.public[] = {
	spec = virtual
	type = bool
	name = assert0
	shortDesc = Check assertion
	longDesc = Log the specified object if the assertion evaluates to \c false.
	param[] = {
		type = bool
		name = assertion
		desc = Assertion to be checked
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (!assertion)\
	log(logObject);
	return = {
		value = assertion
		desc = Value of the assertion
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = assert0
	const = true
	shortDesc = Check assertion
	longDesc = Log the specified object if the assertion evaluates to \c false.
	param[] = {
		type = bool
		name = assertion
		desc = Assertion to be checked
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (!assertion)\
	log(logObject);
	return = {
		value = assertion
		desc = Value of the assertion
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = addRef
	const = true
	shortDesc = Add reference
	longDesc = Add a reference for the object.
	impl = <<<
if (refData->refCount < UINT_MAX)
{
	refData->refCount++;
    if (refData->mmDebug)
        handleMMEvent(IFMMEvent(IFMMEvent::TYPE_ADD_REF, this, 
            refData->refCount));
} else
{
    throw IFError(getErrorString("Reference count overflow.", 
        "addRef"));
}
>>>
	return = {
		value = true
		desc = \c true on success \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeRef
	const = true
	shortDesc = Remove reference
	longDesc = Remove a reference for the object.
	impl = <<<
if (refData->refCount > 0)
{
	refData->refCount--;
    if (refData->mmDebug)
        handleMMEvent(IFMMEvent(IFMMEvent::TYPE_REMOVE_REF, this, 
            refData->refCount));
} else
{
    throw IFError(getErrorString(
        "Attempt to remove reference for object with zero references.", 
            "removeRef"));
}
>>>
	return = {
		value = true
		desc = \c true on success \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumRefs
	const = true
	guardMutex = guardMutex
	bindings = {
		c.enabled = true
		ruby.enabled = true
	}
	shortDesc = Get number of references
	longDesc = Get the number of references for the object.
	impl = 
	return = {
		value = refData->refCount
		desc = Number of references
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = addLocalRef
	const = true
	guardMutex = guardMutex
	bindings = {
		c.enabled = true
		ruby = {
			enabled = true
			numParams = 1
		}
	}
	shortDesc = Add local reference
	longDesc = Add a local reference for the target object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = refTarget
		desc = Target object
	}
	impl = <<<
if (refTarget == 0)
{
	log(IFLogMessage("Attempt to add reference to null object.", 
		VL_ERROR, this, "addLocalRef"));
	return false;
}
IFObjectRefMap::iterator i = refData->refMap.find(refTarget);
IFObjectRefInfo* refInfo = 0;
if ((i != refData->refMap.end())
	&& ((*i).second != 0))
	refInfo = (*i).second;
else
{
	refInfo = new IFObjectRefInfo();
	if (refInfo == 0)
	{
		log(IFLogMessage("Could not allocate "
			"object reference info.", VL_ASSERTION, this, 
			"addLocalRef"));
		return false;
	}
	refInfo->refCount = 0;
	refData->refMap[refTarget] = refInfo;
}
if (!refTarget->addRef())
{
	ostringstream state;
	state << "Could not add reference to object '" 
		<< refTarget->getString() << "'.";
	log(IFLogMessage(state.str(), 
		VL_ERROR, this, "addLocalRef"));
	return false;
}
if (refInfo->refCount < UINT_MAX)
	refInfo->refCount++;
else
{
	log(IFLogMessage("Local reference count overflow.", 
		VL_ERROR, this, "addLocalRef"));
	refTarget->removeRef();
	return false;
}
/* ----- DEBUG ----- //
ostringstream state;
state << "Added local reference to object '" 
	<< refTarget->getString() << "'.";
log(IFLogMessage(state.str(), 
	VL_DEBUG_INSANE, this, "addLocalRef"));
// ----- DEBUG ----- */
if (refTarget->mmDebugEnabled())
    handleMMEvent(IFMMEvent(
        IFMMEvent::TYPE_ADD_LOCAL_REF, refTarget, 
        refInfo->refCount, this));
>>>
	return = {
		value = true
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeLocalRef
	const = true
	shortDesc = Remove local reference
	longDesc = Remove a local reference for the target object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = refTarget
		desc = Target object
	}
	impl = <<<
if (refTarget == 0)
{
	log(IFLogMessage("Attempt to remove reference to null object.", 
		VL_ERROR, this, "removeLocalRef"));
	return false;
}
IFObjectRefMap::iterator i = refData->refMap.find(refTarget);
IFObjectRefInfo* refInfo = 0;
if ((i != refData->refMap.end())
	&& ((*i).second != 0))
	refInfo = (*i).second;
if ((refInfo == 0)
	|| (refInfo->refCount == 0))
{
	ostringstream state;
	state << "Could not remove local reference to object '" 
		<< refTarget->getString() << "': No local references found.";
	log(IFLogMessage(state.str(), 
		VL_ERROR, this, "removeLocalRef"));
	return false;
}
if (refInfo->refCount > 0)
	refInfo->refCount--;
else
{
	log(IFLogMessage("Attempt to remove local reference for object "
		"with zero local references.", VL_ERROR, this, 
		"removeLocalRef"));
	return false;
}
if (refTarget->mmDebugEnabled())
    handleMMEvent(IFMMEvent(
        IFMMEvent::TYPE_REMOVE_LOCAL_REF, refTarget, 
        refInfo->refCount, this));
if (refInfo->refCount == 0)
{
	refData->refMap[refTarget] = 0;
	delete refInfo;
	refInfo = 0;
	refData->refMap.erase(i);
	/* ----- DEBUG ----- //
	ostringstream state;
	state << "Removed local reference info for object '" 
		<< refTarget->getString() << "'.";
	log(IFLogMessage(state.str(), 
		VL_DEBUG_INSANE, this, "removeLocalRef"));
	// ----- DEBUG ----- */
}
if (!refTarget->removeRef())
{
	ostringstream state;
	state << "Could not remove reference to object '" 
		<< refTarget->getString() << "'.";
	log(IFLogMessage(state.str(), 
		VL_ERROR, this, "removeLocalRef"));
	return false;
}
if (refTarget->getNumRefs() == 0)
{
	/* ----- DEBUG ----- //
	ostringstream state;
	state << "Deleting object '" << refTarget->getString() 
		<< "' since there are no more references.";
	log(IFLogMessage(state.str(), 
		VL_DEBUG_INSANE, this, "removeLocalRef"));
	// ----- DEBUG ----- */
	delete refTarget;
	refTarget = 0;
}
/* ----- DEBUG ----- //
if (refTarget != 0)
{
	ostringstream state;
	state << "Removed local reference to object '" 
		<< refTarget->getString() << "'.";
	log(IFLogMessage(state.str(), 
		VL_DEBUG_INSANE, this, "removeLocalRef"));
}
// ----- DEBUG ----- */
>>>
	return = {
		value = true
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeAllLocalRefs
	const = true
	bindings = {
		c.enabled = true
		ruby.enabled = true
	}
	shortDesc = Remove all local references
	longDesc = Remove all local references for other objects.
	impl = IFObjectRefInfo* refInfo = 0;\
IFObjectRefMap::iterator i;\
IFObject* refTarget = 0;\
bool result = true;\
for (i = refData->refMap.begin(); i != refData->refMap.end(); i++)\
\{\
	refTarget = (*i).first;\
	refInfo = (*i).second;\
	if ((refInfo != 0)\
		&& (refTarget != 0))\
	\{\
		while (refInfo->refCount > 0)\
		\{\
			if (!refTarget->removeRef())\
			\{\
				ostringstream state;\
				state << "Could not remove reference to object '" \
					<< refTarget->getString() << "'.";\
				log(IFLogMessage(state.str(), \
					VL_ERROR, this, "removeAllLocalRefs"));\
				result = false;\
			\}\
			refInfo->refCount--;\
			if (refTarget->getNumRefs() == 0)\
			\{\
				/* ----- DEBUG ----- //\
				ostringstream state;\
				state << "Deleting object '" << refTarget->getString() \
					<< "' since there are no more references.";\
				log(IFLogMessage(state.str(), \
					VL_DEBUG_INSANE, this, \
						"removeAllLocalRefs"));\
				// ----- DEBUG ----- */\
				delete refTarget;\
				refTarget = 0;\
			\}\
			/* ----- DEBUG ----- //\
			if (refTarget != 0)\
			\{\
				ostringstream state;\
				state << "Removed local reference to object '" \
					<< refTarget->getString() << "'.";\
				log(IFLogMessage(state.str(), \
					VL_DEBUG_INSANE, this, \
						"removeAllLocalRefs"));\
			\}\
			// ----- DEBUG ----- */\
		\}\
		refData->refMap[refTarget] = 0;\
		delete refInfo;\
		refInfo = 0;\
	\}\
\}\
refData->refMap.clear();
	return = {
		value = result
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumLocalRefs
	const = true
	bindings = {
		c.enabled = true
		ruby.enabled = true
	}
	shortDesc = Get number of local references
	longDesc = Get the number of local referenced for the object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = refTarget
		desc = Target object
	}
	impl = if (refTarget == 0)\
\{\
	log(IFLogMessage("Attempt to get reference count for null object.", \
		VL_ERROR, this, "removeLocalRef"));\
	return false;\
\}\
IFObjectRefMap::iterator i = refData->refMap.find(refTarget);\
IFObjectRefInfo* refInfo = 0;\
if ((i != refData->refMap.end())\
	&& ((*i).second != 0))\
	refInfo = (*i).second;\
if ((refInfo == 0)\
	|| (refInfo->refCount == 0))\
	return 0;
    return = {
		value = refInfo->refCount
		desc = number of local references for the object
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = setGuardEnabled
	shortDesc = Set guard state
	longDesc = Enable or disable object locking. If set to \c true, access to the object in a multi-threaded application will be protected by a guard mutex, if the implementation of the object supports it. Otherwise, the object must be protected by other means.\
\
\note By default, calls to lock(), unlock() or tryLock() will not do anything if guards have not been enabled using this function.
	param[] = {
		type = bool
		name = newGuardState
		desc = Guard state
		value = true
	}
	impl = if (newGuardState)\
\{\
	if (guardMutex != 0)\
		return;\
	guardMutex = new Ionflux::ObjectBase::IFMutex(IFMutex::TYPE_RECURSIVE);\
	if (guardMutex == 0)\
		log(IFLogMessage("Could not allocate guard mutex.", \
			VL_ASSERTION, this, "setGuardEnabled"));\
	addLocalRef(guardMutex);\
\} else\
\{\
	if (guardMutex != 0)\
	\{\
		removeLocalRef(guardMutex);\
		guardMutex = 0;\
	\}\
\}
}
function.public[] = {
	spec = virtual
	type = bool
	name = getGuardEnabled
	shortDesc = Get guard state
	longDesc = Get the current guard state for the object.
	impl = if (guardMutex != 0)\
	return true;
	return = {
		value = false
		desc = \c true if guards and locking are enabled, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = lock
	const = true
	shortDesc = Lock
	longDesc = Lock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->lock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = tryLock
	const = true
	shortDesc = Try to lock
	longDesc = Try to lock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->tryLock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = unlock
	const = true
	shortDesc = Unlock
	longDesc = Unlock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->unlock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::UInt64
	name = getSize
	const = true
	shortDesc = Get size
	longDesc = Get the size of the object.\
\
\note This will always yield DEFAULT_SIZE unless overridden by derived classes.
	impl = 
	return = {
		value = DEFAULT_SIZE
		desc = Size of the object
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLElementName
	const = true
	shortDesc = Get XML element name
	longDesc = Get the XML element name for the object.
	impl = 
	return = {
		value = XML_ELEMENT_NAME
		desc = XML element name
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = getXMLChildData
	const = true
	shortDesc = Get XML child data
	longDesc = Get the XML child data for the object.
	param[] = {
	    type = std::string&
	    name = target
	    desc = Where to store the XML data
	}
	param[] = {
	    type = unsigned int
	    name = indentLevel
	    desc = Indentation level
	    default = 0
	}
	impl = 
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLChildData0
	const = true
	shortDesc = Get XML child data
	longDesc = Get the XML child data for the object.
	param[] = {
	    type = std::string&
	    name = target
	    desc = Where to store the XML data
	}
	param[] = {
	    type = unsigned int
	    name = indentLevel
	    desc = Indentation level
	    default = 0
	}
	impl = std::string cd;\
getXMLChildData(cd, indentLevel);
	return = {
		value = cd
		desc = XML child data
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLAttributeData
	const = true
	shortDesc = Get XML attribute data
	longDesc = Get a string containing the XML attributes of the object.
	impl = std::ostringstream result;\
std::string id0 = getID();\
if (id0.size() > 0)\
    result << "name=\"" << XMLUtils::xmlEscape(id0) << "\"";
	return = {
		value = result.str()
		desc = XML attribute data
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = getXML
	const = true
	shortDesc = Get XML representation
	longDesc = Get an XML representation of the object
	param[] = {
	    type = std::string&
	    name = target
	    desc = Where to store the XML data
	}
	param[] = {
	    type = unsigned int
	    name = indentLevel
	    desc = Indentation level
	    default = 0
	}
	param[] = {
	    type = const std::string&
	    name = attributes
	    desc = Additional attributes for the element
	    default = ""
	}
	impl = std::ostringstream xmlData;\
std::string iws = getIndent(indentLevel);\
std::string en = getXMLElementName();\
xmlData << iws << "<" << en;\
std::string xa = getXMLAttributeData();\
if (xa.size() > 0)\
    xmlData << " " << xa;\
if (attributes.size() > 0)\
    xmlData << " " << attributes;\
std::string cd;\
getXMLChildData(cd, indentLevel + 1);\
if (cd.size() == 0)\
    xmlData << " />";\
else\
    xmlData << ">\n" << cd << "\n" << iws << "</" << en << ">";\
target.append(xmlData.str());
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXML0
	const = true
	shortDesc = Get XML representation
	longDesc = Get an XML representation of the object
	param[] = {
	    type = unsigned int
	    name = indentLevel
	    desc = Indentation level
	    default = 0
	}
	param[] = {
	    type = const std::string&
	    name = attributes
	    desc = Additional attributes for the element
	    default = ""
	}
	impl = std::string xmlData;\
getXML(xmlData, indentLevel, attributes);
    return = {
        value = xmlData
        desc = XML representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = writeToXMLFile
	const = true
	shortDesc = Write object data to XML file
	longDesc = Write the object data to an XML file.
	param[] = {
	    type = const std::string&
	    name = fileName
	    desc = file name
	}
	impl = <<<
std::ofstream f0;
f0.open(fileName.c_str(), ios_base::out);
if (!f0)
{
    std::ostringstream status;
    status << "Could not write to file' " << fileName << "'";
    throw IFError(getErrorString(status.str(), 
        "writeToXMLFile"));
}
std::string xmlData;
getXML(xmlData);
xmlData.append(1, '\n');
f0.write(xmlData.c_str(), xmlData.size());
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = loadFromXMLFile
	shortDesc = Load object data from file
	longDesc = Load object data from an XML file.
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name
	}
    impl = <<<
Ionflux::ObjectBase::XMLUtils::loadFromXMLFile(
    fileName, *this, getXMLElementName());
>>>
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = 
	return = {
		value = ""
		desc = String representation of the value of the object
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = setMMDebug
	shortDesc = Set memory management debugging flag
	longDesc = Set the memory management debugging flag.
	param[] = {
	    type = bool
	    name = newFlag
	    desc = memory management debugging flag
	    default = true
	}
	impl = refData->mmDebug = newFlag;
}
function.public[] = {
	spec = virtual
	type = bool
	name = mmDebugEnabled
	shortDesc = Get memory management debugging flag
	longDesc = Get the memory management debugging flag.
	impl = 
	return = {
	    value = refData->mmDebug
	    desc = memory management debugging flag
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = handleMMEvent
	const = true
	shortDesc = Handle memory management event
	longDesc = Handle memory management event.
	param[] = {
	    type = const Ionflux::ObjectBase::IFMMEvent&
	    name = event
	    desc = event
	}
	impl = IFMMEventHandler* h0 = IFMMEventHandler::getInstance();\
if (h0 != 0)\
    h0->handleMMEvent(event);\
else \{\
    // <---- DEBUG ----- //\
    std::cerr << event << std::endl;\
    // ----- DEBUG ----> */\
\}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getIDString
	const = true
	shortDesc = Get ID string
	longDesc = Get a string identifying the object.
	impl = std::ostringstream status;\
status << getClassName();\
std::string s0 = getID();\
int id0 = getIDNum();\
if ((s0.size() > 0) || (id0 != ID_NUM_UNDEFINED))\
\{\
    status << "{";\
    bool first = true;\
    if (s0.size() > 0)\
    \{\
        status << s0;\
        first = false;\
    \}\
    if (id0 != ID_NUM_UNDEFINED)\
    \{\
        if (!first)\
            status << ", ";\
        status << id0;\
    \}\
    status << "}";\
\}
	return = {
		value = status.str();
		desc = ID string
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getErrorString
	const = true
	shortDesc = Get error string
	longDesc = Get an error string. The error string includes a string representation of the object, an error message and optionally the source of the error (e.g. a function name).
	param[] = {
	    type = const std::string&
	    name = message
	    desc = error message
	}
	param[] = {
	    type = const std::string&
	    name = source
	    desc = error source
	    default = ""
	}
	impl = <<<
std::ostringstream status;
status << "[" << getIDString();
if (source.size() > 0)
    status << "::" << source;
status << "] " << message;
>>>
	return = {
		value = status.str()
		desc = String representation of the object
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = <<<
std::ostringstream status;
status << getIDString();
std::string s0 = getValueString();
if (s0.size() > 0)
    status << "[" << s0 << "]";
>>>
	return = {
		value = status.str()
		desc = String representation of the object
	}
}

# static member functions
function.public[] = {
	spec = static
	type = Ionflux::ObjectBase::XMLUtils::IFXMLObjectFactory*
	name = getXMLObjectFactory
	shortDesc = Get XML object factory
	longDesc = Get the XML object factory singleton for the class.
    impl = <<<
static Ionflux::ObjectBase::XMLUtils::IFXMLObjectFactory* fac0 = 0;
if (fac0 == 0)
{
    fac0 = Ionflux::ObjectBase::XMLUtils::IFXMLObjectFactory::create();
    fac0->addRef();
}
>>>
    return = {
        value = fac0
        desc = XML object factory singleton
    }
}

# operations
operation[] = {
	name = log
#	const = true
	param[] = {
		type = Ionflux::ObjectBase::IFObject
		name = logObject
		desc = Object to be logged
#		optional = false
#		default = 0
	}
#	result[] = {
#		type = Ionflux::ObjectBase::IFObject
#	}
	impl = if (logObject != 0)\
	log(*logObject);\
return true;
	constImpl = if (logObject != 0)\
	log(*logObject);\
return true;
}

# Global functions.
function.global[] = {
	type = std::ostream&
	name = operator<<
	shortDesc = Output operator
	longDesc = Output operator
	param[] = {
		type = std::ostream&
		name = outputStream
		desc = Output stream
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = source
		desc = Source object
	}
	return = {
		value = outputStream << source.getString()
		desc = Output stream
	}
}

