# ==========================================================================
# Ionflux Object Base System
# Copyright Â© 2006 Joern P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# IFObject.conf          Class definition file
# ==========================================================================
# 
# This file is part of Ionflux Object Base System.
# 
# Ionflux Object Base System is free software; you can redistribute it 
# and/or modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation; either version 2 of the 
# License, or (at  your option) any later version.
# 
# Ionflux Object Base System is distributed in the hope that it will be 
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Object Base System; if not, write to the Free 
# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	header = {
		'<string>'
		'<vector>'
		'<set>'
		'<map>'
		'<iostream>'
		'"sigc++/signal.h"'
		'"sigc++/connection.h"'
		'"ifobject/types.hpp"'
		'"ifobject/IFClassInfo.hpp"'
	}
	impl = {
		'<sstream>'
	}
}

# Undefine macros.
undef.header = {
	'assert'
}

# Forward declarations.
forward = {
	'class IFMutex'
}

# Typedefs.

# Helper structs.
struct[] = {
	name = IFObjectRefInfo
	desc = Object reference information
	field[] = {
		type = unsigned int
		name = refCount
		desc = Reference count
	}
}
struct[] = {
	name = IFRefCountData
	desc = Reference counting data
	field[] = {
		type = IFObjectRefMap
		name = refMap
		desc = Local reference map
	}
	field[] = {
		type = unsigned int
		name = refCount
		desc = Reference count
	}
}

# events
event[] = {
	id = object
	# using directives
	using = {
		'namespace std'
	}
	# include files.
	include = {
	   header = {
			'"ifobject/types.hpp"'
			'"ifobject/IFObject.hpp"'
	   }
	}
	# forward declarations
	forward = {
	 	'class IFObject'
	}
	# default constructor
	constructor.default = {
		initializer[] = {
			name = type
			value = TYPE_OBJECT_CHANGED
		}
		initializer[] = {
			name = source
			value = 0
		}
		initializer[] = {
			name = oldIDNum
			value = 0
		}
		initializer[] = {
			name = newIDNum
			value = 0
		}
		initializer[] = {
			name = oldID
			value = ""
		}
		initializer[] = {
			name = newID
			value = ""
		}
	}
	# constants
	constant.public[] = {
		name = TYPE_OBJECT_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: object changed
		value = 0
	}
	constant.public[] = {
		name = TYPE_ID_NUM_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: ID number changed
		value = 1
	}
	constant.public[] = {
		name = TYPE_ID_CHANGED
		type = Ionflux::ObjectBase::IFEventType
		desc = event type: ID changed
		value = 2
	}
	# properties (protected)
	property.protected[] = {
		type = Ionflux::ObjectBase::IFEventType
		setFromType = Ionflux::ObjectBase::IFEventType
		name = type
		desc = event type
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObject*
		setFromType = Ionflux::ObjectBase::IFObject*
		name = source
		desc = event source
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFIDNum
		setFromType = Ionflux::ObjectBase::IFIDNum
		name = oldIDNum
		desc = old ID number
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFIDNum
		setFromType = Ionflux::ObjectBase::IFIDNum
		name = newIDNum
		desc = new ID number
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObjectID
		setFromType = const Ionflux::ObjectBase::IFObjectID&
		name = oldID
		desc = old ID
	}
	property.protected[] = {
		type = Ionflux::ObjectBase::IFObjectID
		setFromType = const Ionflux::ObjectBase::IFObjectID&
		name = newID
		desc = new ID
	}
}

# signals
signal[] = {
	id = object
	return.type = bool
	param[].type = const Ionflux::ObjectBase::IFObjectEvent&
	instance[] = {
		name = objectChanged
		desc = object changed signal
		id = object_changed
	}
	instance[] = {
		name = objectIDNumChanged
		desc = object ID number changed signal
		id = object_id_num_changed
	}
	instance[] = {
		name = objectIDChanged
		desc = object ID changed signal
		id = object_id_changed
	}
}

# Class definition.
class = {
	name = IFObject
	shortDesc = Object
	title = Object
	longDesc = Base class for all objects. Access to the object in a multi-threaded application can be protected by a guard mutex with a call to setGuardEnabled().
	group.name = ifobject
	group.shortDesc = Ionflux Object Base System
	group.longDesc = Classes implementing the core functionality of the Ionflux Object Base System.
	features = {
		'guards'
		'logmessage'
	}
}

# Public constructors.
constructor.default = {
	initializer[] = {
		name = idNum
		value = ID_NUM_UNDEFINED
	}
	initializer[] = {
		name = refData
		value = 0
	}
	initializer[] = {
		name = guardMutex
		value = 0
	}
	initializer[] = {
		name = logTarget
		value = 0
	}
	impl = /* NOTE: Creating IFObjects here will cause an infinite loop. \
         (Don't do it.) */\
refData = new IFRefCountData();\
if (refData == 0)\
\{\
	std::cerr << "[IFObject::IFObject] ERROR: "\
		"Could not allocate reference count data structure "\
		"(this is bad, exiting)." << std::endl;\
	exit(-1);\
\}\
refData->refCount = 0;
}

# Destructor.
destructor.impl = removeAllLocalRefs();\
delete refData;\
refData = 0;

# Protected variables.
variable.protected[] = {
	name = theClass
	type = const Ionflux::ObjectBase::IFClassInfo*
	desc = Class info
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFObjectID
	name = id
	desc = Object ID
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFIDNum
	name = idNum
	desc = ID number
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFRefCountData*
	name = refData
	desc = Reference counting data
}
variable.protected[] = {
	type = Ionflux::ObjectBase::IFMutex*
	name = guardMutex
	desc = Guard mutex
}

# Class properties.
property.protected[] = {
	type = Ionflux::ObjectBase::IFObject*
	setFromType = Ionflux::ObjectBase::IFObject*
	name = logTarget
	desc = Log target
	managed = true
}

# Public static constants.
constant.public[] = {
	type = IFIDNum
	name = ID_NUM_UNDEFINED
	desc = ID number: undefined
	value = -1
	bindings.ruby.type = int
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.public[] = {
	spec = virtual
	type = const Ionflux::ObjectBase::IFClassInfo*
	name = getClass
	const = true
	shortDesc = Get class information
	longDesc = Get the class information.
	return = {
		value = theClass
		desc = The class information, or 0 if no class information exists for this class
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getClassName
	const = true
	shortDesc = Get class name
	longDesc = Get the class name
	impl = const IFClassInfo* theClassInfo = getClass();\
if (theClassInfo != 0)\
	return theClassInfo->getName();
	return = {
		value = ""
		desc = The class name
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getClassDesc
	const = true
	shortDesc = Get class description
	longDesc = Get the class description
	impl = const IFClassInfo* theClassInfo = getClass();\
if (theClassInfo != 0)\
	return theClassInfo->getDesc();
	return = {
		value = ""
		desc = The class description
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = setID
	shortDesc = Set object ID
	longDesc = Set the object ID
	param[] = {
		type = const Ionflux::ObjectBase::IFObjectID&
		name = newID
		desc = Object ID
	}
	impl = IFObjectEvent* event = createObjectEvent();\
event->setType(IFObjectEvent::TYPE_OBJECT_ID_CHANGED);\
event->setOldID(id);\
event->setNewID(newID);\
id = newID;\
signalObjectIDChanged.emit(*event);\
removeLocalRef(event);
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::ObjectID
	name = getID
	const = true
	shortDesc = Get object ID
	longDesc = Get the object ID
	return.value = id
	return.desc = The object ID
}
function.public[] = {
	spec = virtual
	type = void
	name = setIDNum
	shortDesc = Set ID number
	longDesc = Set the ID number
	param[] = {
		type = Ionflux::ObjectBase::IFIDNum
		name = newIDNum
		desc = ID number
	}
	impl = IFObjectEvent* event = createObjectEvent();\
event->setType(IFObjectEvent::TYPE_OBJECT_ID_NUM_CHANGED);\
event->setOldIDNum(idNum);\
event->setNewIDNum(newIDNum);\
idNum = newIDNum;\
signalObjectIDNumChanged.emit(*event);\
removeLocalRef(event);
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFIDNum
	name = getIDNum
	const = true
	shortDesc = Get ID number
	longDesc = Get the ID number
	return.value = idNum
	return.desc = The ID number
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName();\
if (id.size() > 0)\
	state << "{" << id << "}";
	return = {
		value = state.str()
		desc = String representation of the object
	}
}
function.public[] = {
	spec = virtual
	name = operator std::string
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	return = {
		value = getString()
		desc = String representation of the object
	}
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFObject*
	name = copy
	const = true
	shortDesc = Copy
	longDesc = Create a copy of the object.
	impl = log(IFLogMessage("Copy operation not implemented.", \
	IFLogMessage::VL_ERROR, this, "copy"));
	return = {
		value = 0
		desc = Copy of the object
	}
}
function.public[] = {
	spec = static
	type = Ionflux::ObjectBase::IFObject*
	name = create
	shortDesc = Create instance
	longDesc = Create a new instance of the class. If the optional parent object is specified, a local reference for the new object will be added to the parent object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = parentObject
		desc = Parent object
		default = 0
	}
	impl = IFObject* newObject = new IFObject();\
if (newObject == 0)\
\{\
	cerr << IFLogMessage("Could not allocate object instance.", \
		IFLogMessage::VL_ERROR, 0, "IFObject::create") << endl;\
	return 0;\
\}\
if (parentObject != 0)\
	parentObject->addLocalRef(newObject);
	return = {
		value = newObject
		desc = Pointer to the new instance, or 0 if an error occurs
	}
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::IFObject&
	name = operator=
	shortDesc = Assignment operator
	longDesc = Assignment operator.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = otherObject
		desc = Object
	}
	impl = log(IFLogMessage("Assignment operator not implemented.", \
	IFLogMessage::VL_ERROR, this, "operator="));
	return = {
		value = *this
		desc = The object itself
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	shortDesc = Log object
	longDesc = Log an object. If no log target has been set, the default implementation just writes the string representation of the object to standard output. If a log target has been set, the log() function of the target will be called.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (logTarget == 0)\
	cout << logObject << endl;\
else\
	logTarget->log(logObject);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	shortDesc = Log object
	longDesc = Causes the object to log itself.
	impl = log(*this);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	const = true
	shortDesc = Log object
	longDesc = Log an object. If no log target has been set, the default implementation just writes the string representation of the object to standard output. If a log target has been set, the log() function of the target will be called.
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (logTarget == 0)\
	cout << logObject << endl;\
else\
	logTarget->log(logObject);
}
function.public[] = {
	spec = virtual
	type = void
	name = log
	const = true
	shortDesc = Log object
	longDesc = Causes the object to log itself.
	impl = log(*this);
}
function.public[] = {
	spec = virtual
	type = bool
	name = assert
	shortDesc = Check assertion
	longDesc = Log the specified object if the assertion evaluates to \c false.
	param[] = {
		type = bool
		name = assertion
		desc = Assertion to be checked
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (!assertion)\
	log(logObject);
	return = {
		value = assertion
		desc = Value of the assertion
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = assert
	const = true
	shortDesc = Check assertion
	longDesc = Log the specified object if the assertion evaluates to \c false.
	param[] = {
		type = bool
		name = assertion
		desc = Assertion to be checked
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = logObject
		desc = Object to be logged
	}
	impl = if (!assertion)\
	log(logObject);
	return = {
		value = assertion
		desc = Value of the assertion
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = addRef
	const = true
	shortDesc = Add reference
	longDesc = Add a reference for the object.
	impl = if (refData->refCount < UINT_MAX)\
	refData->refCount++;\
else\
\{\
	log(IFLogMessage("Reference count overflow.", \
		IFLogMessage::VL_ERROR, this, "addRef"));\
	return false;\
\}
	return = {
		value = true
		desc = \c true on success \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeRef
	const = true
	shortDesc = Remove reference
	longDesc = Remove a reference for the object.
	impl = if (refData->refCount > 0)\
	refData->refCount--;\
else\
\{\
	log(IFLogMessage("Attempt to remove reference for object "\
		"with zero references.", IFLogMessage::VL_ERROR, this, "removeRef"));\
	return false;\
\}
	return = {
		value = true
		desc = \c true on success \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumRefs
	const = true
	guardMutex = guardMutex
	bindings = {
		c.enabled = true
		ruby.enabled = true
	}
	shortDesc = Get number of references
	longDesc = Get the number of references for the object.
	impl = 
	return = {
		value = refData->refCount
		desc = Number of references
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = addLocalRef
	const = true
	guardMutex = guardMutex
	bindings = {
		c.enabled = true
		ruby = {
			enabled = true
			numParams = 1
		}
	}
	shortDesc = Add local reference
	longDesc = Add a local reference for the target object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = refTarget
		desc = Target object
	}
	impl = if (refTarget == 0)\
\{\
	log(IFLogMessage("Attempt to add reference to null object.", \
		IFLogMessage::VL_ERROR, this, "addLocalRef"));\
	return false;\
\}\
IFObjectRefMap::iterator i = refData->refMap.find(refTarget);\
IFObjectRefInfo* refInfo = 0;\
if ((i != refData->refMap.end())\
	&& ((*i).second != 0))\
	refInfo = (*i).second;\
else\
\{\
	refInfo = new IFObjectRefInfo();\
	if (refInfo == 0)\
	\{\
		log(IFLogMessage("Could not allocate "\
			"object reference info.", IFLogMessage::VL_ASSERTION, this, \
			"addLocalRef")))\
		return false;\
	\}\
	refInfo->refCount = 0;\
	refData->refMap[refTarget] = refInfo;\
\}\
if (!refTarget->addRef())\
\{\
	ostringstream state;\
	state << "Could not add reference to object '" \
		<< refTarget->getString() << "'.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_ERROR, this, "addLocalRef"));\
	return false;\
\}\
if (refInfo->refCount < UINT_MAX)\
	refInfo->refCount++;\
else\
\{\
	log(IFLogMessage("Local reference count overflow.", \
		IFLogMessage::VL_ERROR, this, "addLocalRef"));\
	refTarget->removeRef();\
	return false;\
\}\
/* ----- DEBUG ----- //\
ostringstream state;\
state << "Added local reference to object '" \
	<< refTarget->getString() << "'.";\
log(IFLogMessage(state.str(), \
	IFLogMessage::VL_DEBUG_INSANE, this, "addLocalRef"));\
// ----- DEBUG ----- */
	return = {
		value = true
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeLocalRef
	const = true
	shortDesc = Remove local reference
	longDesc = Remove a local reference for the target object.
	param[] = {
		type = Ionflux::ObjectBase::IFObject*
		name = refTarget
		desc = Target object
	}
	impl = if (refTarget == 0)\
\{\
	log(IFLogMessage("Attempt to remove reference to null object.", \
		IFLogMessage::VL_ERROR, this, "removeLocalRef"));\
	return false;\
\}\
IFObjectRefMap::iterator i = refData->refMap.find(refTarget);\
IFObjectRefInfo* refInfo = 0;\
if ((i != refData->refMap.end())\
	&& ((*i).second != 0))\
	refInfo = (*i).second;\
if ((refInfo == 0)\
	|| (refInfo->refCount == 0))\
\{\
	ostringstream state;\
	state << "Could not remove local reference to object '" \
		<< refTarget->getString() << "': No local references found.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_ERROR, this, "removeLocalRef"));\
	return false;\
\}\
if (refInfo->refCount > 0)\
	refInfo->refCount--;\
else\
\{\
	log(IFLogMessage("Attempt to remove local reference for object "\
		"with zero local references.", IFLogMessage::VL_ERROR, this, \
		"removeLocalRef"));\
	return false;\
\}\
if (refInfo->refCount == 0)\
\{\
	refData->refMap[refTarget] == 0;\
	delete refInfo;\
	refInfo = 0;\
	refData->refMap.erase(i);\
	/* ----- DEBUG ----- //\
	ostringstream state;\
	state << "Removed local reference info for object '" \
		<< refTarget->getString() << "'.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_DEBUG_INSANE, this, "removeLocalRef"));\
	// ----- DEBUG ----- */\
\}\
if (!refTarget->removeRef())\
\{\
	ostringstream state;\
	state << "Could not remove reference to object '" \
		<< refTarget->getString() << "'.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_ERROR, this, "removeLocalRef"));\
	return false;\
\}\
if (refTarget->getNumRefs() == 0)\
\{\
	/* ----- DEBUG ----- //\
	ostringstream state;\
	state << "Deleting object '" << refTarget->getString() \
		<< "' since there are no more references.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_DEBUG_INSANE, this, "removeLocalRef"));\
	// ----- DEBUG ----- */\
	delete refTarget;\
	refTarget = 0;\
\}\
/* ----- DEBUG ----- //\
if (refTarget != 0)\
\{\
	ostringstream state;\
	state << "Removed local reference to object '" \
		<< refTarget->getString() << "'.";\
	log(IFLogMessage(state.str(), \
		IFLogMessage::VL_DEBUG_INSANE, this, "removeLocalRef"));\
\}\
// ----- DEBUG ----- */
	return = {
		value = true
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeAllLocalRefs
	const = true
	bindings = {
		c.enabled = true
		ruby.enabled = true
	}
	shortDesc = Remove all local references
	longDesc = Remove all local references for other objects.
	impl = IFObjectRefInfo* refInfo = 0;\
IFObjectRefMap::iterator i;\
IFObject* refTarget = 0;\
bool result = true;\
for (i = refData->refMap.begin(); i != refData->refMap.end(); i++)\
\{\
	refTarget = (*i).first;\
	refInfo = (*i).second;\
	if ((refInfo != 0)\
		&& (refTarget != 0))\
	\{\
		while (refInfo->refCount > 0)\
		\{\
			if (!refTarget->removeRef())\
			\{\
				ostringstream state;\
				state << "Could not remove reference to object '" \
					<< refTarget->getString() << "'.";\
				log(IFLogMessage(state.str(), \
					IFLogMessage::VL_ERROR, this, "removeAllLocalRefs"));\
				result = false;\
			\}\
			refInfo->refCount--;\
			if (refTarget->getNumRefs() == 0)\
			\{\
				/* ----- DEBUG ----- //\
				ostringstream state;\
				state << "Deleting object '" << refTarget->getString() \
					<< "' since there are no more references.";\
				log(IFLogMessage(state.str(), \
					IFLogMessage::VL_DEBUG_INSANE, this, \
						"removeAllLocalRefs"));\
				// ----- DEBUG ----- */\
				delete refTarget;\
				refTarget = 0;\
			\}\
			/* ----- DEBUG ----- //\
			if (refTarget != 0)\
			\{\
				ostringstream state;\
				state << "Removed local reference to object '" \
					<< refTarget->getString() << "'.";\
				log(IFLogMessage(state.str(), \
					IFLogMessage::VL_DEBUG_INSANE, this, \
						"removeAllLocalRefs"));\
			\}\
			// ----- DEBUG ----- */\
		\}\
		refData->refMap[refTarget] = 0;\
		delete refInfo;\
		refInfo = 0;\
	\}\
\}\
refData->refMap.clear();
	return = {
		value = result
		desc = \c true on success \c false otherwise.
	}
}
function.public[] = {
	spec = virtual
	type = void
	name = setGuardEnabled
	shortDesc = Set guard state
	longDesc = Enable or disable guards and object locking. If set to \c true, access to the object in a multi-threaded application will be protected by a guard mutex, if the implementation of the object supports it. Otherwise, the object must be protected by other means.\
\
\note By default, calls to lock(), unlock() or tryLock() will not do anything if guards have not been enabled using this function.
	param[] = {
		type = bool
		name = newGuardState
		desc = Guard state
		value = true
	}
	impl = if (newGuardState)\
\{\
	if (guardMutex != 0)\
		return;\
	guardMutex = new Ionflux::ObjectBase::IFMutex(IFMutex::TYPE_RECURSIVE);\
	if (guardMutex == 0)\
		log(IFLogMessage("Could not allocate guard mutex.", \
			IFLogMessage::VL_ASSERTION, this, "setGuardEnabled"));\
	addLocalRef(guardMutex);\
\} else\
\{\
	if (guardMutex != 0)\
	\{\
		removeLocalRef(guardMutex);\
		guardMutex = 0;\
	\}\
\}
}
function.public[] = {
	spec = virtual
	type = bool
	name = getGuardEnabled
	shortDesc = Get guard state
	longDesc = Get the current guard state for the object.
	impl = if (guardMutex != 0)\
	return true;
	return = {
		value = false
		desc = \c true if guards and locking are enabled, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = lock
	const = true
	shortDesc = Lock
	longDesc = Lock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->lock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = tryLock
	const = true
	shortDesc = Try to lock
	longDesc = Try to lock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->tryLock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}
function.public[] = {
	spec = virtual
	type = bool
	name = unlock
	const = true
	shortDesc = Unlock
	longDesc = Unlock the object. This may be necessary for using certain member functions which are not thread safe.\
\
\note Locking must be enabled using setGuardEnabled() for this function to have an effect. If guards are disabled, the function will always return \c true.
	impl = if (guardMutex != 0)\
	return guardMutex->unlock();
	return = {
		value = true
		desc = \c true on success, \c false otherwise
	}
}

# Global functions.
function.global[] = {
	type = std::ostream&
	name = operator<<
	shortDesc = Output operator
	longDesc = Output operator
	param[] = {
		type = std::ostream&
		name = outputStream
		desc = Output stream
	}
	param[] = {
		type = const Ionflux::ObjectBase::IFObject&
		name = source
		desc = Source object
	}
	return.value = outputStream << source.getString()
	return.desc = Output stream
}
