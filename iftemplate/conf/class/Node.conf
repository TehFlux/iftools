# ==========================================================================
# IFTemplate - Ionflux Template Processor
# Copyright © 2012-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Node.conf              Class configuration.
# ==========================================================================
# 
# This file is part of IFTemplate - Ionflux Template Processor.
# 
# IFTemplate - Ionflux Template Processor is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# IFTemplate - Ionflux Template Processor is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
    'namespace std'
}

# include files.
include = {
    # these includes will be added in the header file
    header = {
        '<string>'
        '"ifobject/types.hpp"'
        '"iftemplate/types.hpp"'
    }
    # these includes will be added in the implementation file
    impl = {
        '<iostream>'
        '<iomanip>'
        '<sstream>'
        '<cstdlib>'
        '"ifobject/serialize.hpp"'
        '"ifobject/utils.hpp"'
        '"iftemplate/utils.hpp"'
        '"iftemplate/NodeDump.hpp"'
        '"iftemplate/IFTemplateError.hpp"'
    }
}

# forward declarations
forward = {
    'class NodeDump'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
    name = Node
    shortDesc = Tree node
    title = Tree node
    longDesc = A single data node of a tree. Tree nodes can be used to store data of a hierarchical, non-cyclical structure, where each child node has exactly one parent node and loops do not exist. Each node also has a data vector  where a large amount of values of identical type may be stored without the need of additional nodes. The type of a node can be one of BLOB, INT or DOUBLE, and all data will be converted as best as possible to fit the  specified node data type. The node object also provides transparent  serialization and unpacking of sub-trees from a data buffer and node  resolution from a fully qualified tree path (see  docs/node-serialization.txt and docs/path-resolution.txt for additional  information). Dynamic auto-creation of child nodes is also supported.
    group.name = iftemplate
    base = {
        # base classes from the IFObject hierarchy
        ifobject[] = {
            name = IFObject
        }
        #other[] = {
        #    name = 
        #    include = 
        #}
    }
    # Features.
    features = {
        'create'
        'copy'
        'upcast'
        'classinfo'
    }
    create = {
        extendedCreate = true
        allocationError = IFTemplateError("Could not allocate object.")
    }
}

# Member variables.
variable.protected[] = {
    type = Ionflux::Template::NodeVector
    name = children
    desc = Child nodes
}
variable.protected[] = {
    type = Ionflux::ObjectBase::StringVector
    name = nodeData
    desc = Data entries
}
variable.protected[] = {
    type = Ionflux::Template::NodeNameMap
    name = nameIndex
    desc = Node index by name
}
variable.protected[] = {
    type = Ionflux::Template::NodeVector
    name = idIndex
    desc = Node index by ID
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::Template::NodeID
    setFromType = Ionflux::Template::NodeID
    name = nodeID
    desc = Numerical ID
    impl.set = int oldID = nodeID;\
nodeID = newNodeID;\
if (parent != 0)\
\{\
    parent->removeIndexEntry(oldID);\
    parent->addIndexEntry(this);\
\}
}
property.protected[] = {
    type = std::string
    setFromType = const std::string&
    name = nodeName
    desc = Name of the node
    impl.set = string oldName = nodeName;\
nodeName = newNodeName;\
if (parent != 0)\
\{\
    parent->removeIndexEntry(oldName);\
    parent->addIndexEntry(this);\
\}
}
property.protected[] = {
    type = Ionflux::Template::NodeDataTypeID
    setFromType = Ionflux::Template::NodeDataTypeID
    name = dataType
    desc = Data type
}
property.protected[] = {
    type = Ionflux::Template::Node*
    setFromType = Ionflux::Template::Node*
    name = parent
    desc = Parent node
}
property.protected[] = {
    type = Ionflux::Template::NodeID
    setFromType = Ionflux::Template::NodeID
    name = maxUID
    desc = Maximum UID that has been assigned by this node
}
property.protected[] = {
    type = Ionflux::Template::NodeUIDMode
    setFromType = Ionflux::Template::NodeUIDMode
    name = uidMode
    desc = Child node UID assignment mode
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = autoCreate
    desc = Create requested child nodes and data entries on the fly
}
property.protected[] = {
    type = Ionflux::Template::NodeIndexMode
    setFromType = Ionflux::Template::NodeIndexMode
    name = indexMode
    desc = Child node indexing mode
}

# Public static constants.
constant.public[] = {
    type = Ionflux::Template::NodeID
    name = ID_NOT_SET
    desc = Node ID: not set
    value = -1
}
constant.public[] = {
    type = Ionflux::Template::NodeDataTypeID
    name = DATA_BLOB
    desc = Node data type: blob (binary large object, including byte strings)
    value = 0
}
constant.public[] = {
    type = Ionflux::Template::NodeDataTypeID
    name = DATA_INT
    desc = Node data type: integer
    value = 1
}
constant.public[] = {
    type = Ionflux::Template::NodeDataTypeID
    name = DATA_DOUBLE
    desc = Node data type: double precision floating point number
    value = 2
}
constant.public[] = {
    type = Ionflux::Template::NodeUIDMode
    name = UID_MODE_NONE
    desc = Child node UID assignment mode: Do not assign UID (default)
    value = 0
}
constant.public[] = {
    type = Ionflux::Template::NodeUIDMode
    name = UID_MODE_NODE
    desc = Child node UID assignment mode: Assign ID unique to the parent node
    value = 1
}
constant.public[] = {
    type = Ionflux::Template::NodeUIDMode
    name = UID_MODE_TREE
    desc = Child node UID assignment mode: Assign ID unique to the tree
    value = 2
}
constant.public[] = {
    type = Ionflux::Template::NodeTraversalMode
    name = TRAVERSAL_INORDER
    desc = Traversal order: inorder
    value = 0
}
constant.public[] = {
    type = Ionflux::Template::NodeTraversalMode
    name = TRAVERSAL_PREORDER
    desc = Traversal order: preorder
    value = 1
}
constant.public[] = {
    type = Ionflux::Template::NodeTraversalMode
    name = TRAVERSAL_POSTORDER
    desc = Traversal order: postorder
    value = 2
}
constant.public[] = {
    type = unsigned int
    name = HEADER_SIZE
    desc = Size of serialized node header in bytes
    value = 53
}
constant.public[] = {
    type = Ionflux::Template::NodeIndexMode
    name = INDEX_MODE_NONE
    desc = Indexing mode: Do not use indexing (default)
    value = 0
}
constant.public[] = {
    type = Ionflux::Template::NodeIndexMode
    name = INDEX_MODE_NODE
    desc = Indexing mode: Per node indexing
    value = 1
}
constant.public[] = {
    type = Ionflux::Template::NodeIndexMode
    name = INDEX_MODE_TREE
    desc = Indexing mode: Per tree indexing
    value = 2
}
constant.public[] = {
    type = unsigned int
    name = MAX_ID_INDEX_SIZE
    desc = Maximum size of ID index
    value = 268435456L
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;\
setNodeName(other.nodeName);\
setNodeID(other.nodeID);
constructor.default = {
    initializer[] = {
        name = nodeID
        value = ID_NOT_SET
    }
    initializer[] = {
        name = nodeName
        value = ""
    }
    initializer[] = {
        name = dataType
        value = DATA_BLOB
    }
    initializer[] = {
        name = parent
        value = 0
    }
    initializer[] = {
        name = maxUID
        value = -1
    }
    initializer[] = {
        name = uidMode
        value = UID_MODE_NONE
    }
    initializer[] = {
        name = autoCreate
        value = false
    }
    initializer[] = {
        name = indexMode
        value = INDEX_MODE_NONE
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = nodeID
        value = ID_NOT_SET
    }
    initializer[] = {
        name = nodeName
        value = ""
    }
    initializer[] = {
        name = dataType
        value = DATA_BLOB
    }
    initializer[] = {
        name = parent
        value = initParent
    }
    initializer[] = {
        name = maxUID
        value = -1
    }
    initializer[] = {
        name = uidMode
        value = UID_MODE_NONE
    }
    initializer[] = {
        name = autoCreate
        value = false
    }
    initializer[] = {
        name = indexMode
        value = INDEX_MODE_NONE
    }
    param[] = {
        type = Ionflux::Template::Node*
        name = initParent
        desc = parent node
    }
    impl = // NOTE: This constructor should not be used anymore.\
std::cerr << "[Node::Node] WARNING: "\
    "Using deprecated constructor to set parent node." << std::endl;
}
constructor.public[] = {
    initializer[] = {
        name = nodeID
        value = initID
    }
    initializer[] = {
        name = nodeName
        value = initName
    }
    initializer[] = {
        name = dataType
        value = initDataType
    }
    initializer[] = {
        name = parent
        value = initParent
    }
    initializer[] = {
        name = maxUID
        value = -1
    }
    initializer[] = {
        name = uidMode
        value = UID_MODE_NONE
    }
    initializer[] = {
        name = autoCreate
        value = false
    }
    initializer[] = {
        name = indexMode
        value = INDEX_MODE_NONE
    }
    param[] = {
        type = Ionflux::Template::Node*
        name = initParent
        desc = parent node
    }
    param[] = {
        type = Ionflux::Template::NodeID
        name = initID
        desc = node ID
    }
    param[] = {
        type = const std::string&
        name = initName
        desc = node name
        default = ""
    }
    param[] = {
        type = Ionflux::Template::NodeDataTypeID
        name = initDataType
        desc = node data type
        default = DATA_BLOB
    }
    impl = 
}

# Destructor.
destructor.impl = clearData(false);\
removeAllChildren(false);

# Protected member functions.
function.protected[] = {
    spec = virtual
    type = bool
    name = validateChildIndex
    shortDesc = Validate child node index
    longDesc = Check whether the child node index references a valid child node.\
\
\note If the child node does not exist, but auto-create mode is set to \c true, the child node will be created.
    param[] = {
        type = unsigned int
        name = childIndex
        desc = child node index to be validated
    }
    impl = if ((childIndex >= 0) && (childIndex < children.size()))\
    return true;\
else\
if ((childIndex >= 0) && autoCreate)\
    while (childIndex != (children.size() - 1))\
    \{\
        /* Add appropriate empty child nodes until there is a valid child \
           node with the specified index. */\
        addChild();\
    \}\
else\
    return false;
    return = {
        value = true
        desc = \c true if a child node with specified index exists, \c false otherwise.
    }
}
function.protected[] = {
    spec = virtual
    type = bool
    name = validateChildIndex
    const = true
    shortDesc = Validate child node index
    longDesc = Check whether the child node index references a valid child node.\
\
\note If the child node does not exist, but auto-create mode is set to \c true, the child node will be created.
    param[] = {
        type = unsigned int
        name = childIndex
        desc = child node index to be validated
    }
    impl = if ((childIndex >= 0) && (childIndex < children.size()))\
    return true;
    return = {
        value = false
        desc = \c true if a child node with specified index exists, \c false otherwise.
    }
}
function.protected[] = {
    spec = virtual
    type = bool
    name = validateDataIndex
    shortDesc = Validate data index
    longDesc = Check whether the data index references a valid data entry.\
\
\note If the data entry does not exist, but auto-create mode is set to \c true, the data entry will be created.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = data index to be validated
    }
    impl = if ((dataIndex >= 0) && (dataIndex < nodeData.size()))\
    return true;\
else\
if ((dataIndex >= 0) && autoCreate)\
    while (dataIndex != (nodeData.size() - 1))\
    \{\
        /* Add appropriate empty data entries until there is a valid data \
           entry with the specified index. */\
        switch (dataType)\
        \{\
            case DATA_BLOB:\
                addData("");\
                break;\
            case DATA_INT:\
                addData(0);\
                break;\
            case DATA_DOUBLE:\
                addData(0.0);\
                break;\
            default:\
                addData("");\
        \}\
    \}\
else\
    return false;
    return = {
        value = true
        desc = \c true if a data entry with specified index exists, \c false otherwise.
    }
}
function.protected[] = {
    spec = virtual
    type = bool
    const = true
    name = validateDataIndex
    shortDesc = Validate data index
    longDesc = Check whether the data index references a valid data entry.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = data index to be validated
    }
    impl = if ((dataIndex >= 0) && (dataIndex < nodeData.size()))\
    return true;
    return = {
        value = false
        desc = \c true if a data entry with specified index exists, \c false otherwise.
    }
}
function.protected[] = {
    spec = virtual
    type = void
    name = addIndexEntry
    shortDesc = Add index entry
    longDesc = Adds a child node to the name or ID index (or both).\
\
\note A child node will be added to an index only if either its name is not the empty string or its ID is not ID_NOT_SET and not negative. If both keys (name or ID) are set to suitable values, the node will be added to both indexes. If the indexing mode is INDEX_MODE_NONE or \c indexNode is 0, this function will do nothing.
    param[] = {
        type = Ionflux::Template::Node*
        name = indexNode
        desc = node for which to add an index entry
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexNode == 0))
    return;
if ((indexMode == INDEX_MODE_TREE) && (parent != 0))
{
    parent->addIndexEntry(indexNode);
    return;
}
string indexName = indexNode->getNodeName();
int indexID = indexNode->getNodeID();
if (indexName.size() > 0)
{
    /* ----- DEBUG ----- //
    cout << "Adding name index entry for name '" << indexName << "'." 
        << endl;
    // ----- DEBUG ----- */
    nameIndex[indexName] = indexNode;
}
if ((indexID != ID_NOT_SET) && (indexID >= 0) 
    && (static_cast<unsigned int>(indexID) < MAX_ID_INDEX_SIZE))
{
    // Resize the index by adding empty elements.
    while (idIndex.size() <= static_cast<unsigned int>(indexID))
        idIndex.push_back(0);
    /* ----- DEBUG ----- //
    cout << "Adding ID index entry for ID " << indexID << "." << endl;
    // ----- DEBUG ----- */
    idIndex[indexID] = indexNode;
}
>>>
}
function.protected[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = getIndexEntry
    const = true
    shortDesc = Get index entry
    longDesc = Retreives a child node info record by name.\
\
\note If a corresponding index entry is not found or the indexing mode is INDEX_MODE_NONE or \c indexName is empty, this function will return 0.
    param[] = {
        type = const std::string&
        name = indexName
        desc = name to search for
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexName.size() == 0))
    return 0;
if ((indexMode == INDEX_MODE_TREE) && (parent != 0))
    return parent->getIndexEntry(indexName);
NodeNameMap::const_iterator i = nameIndex.find(indexName);
if (i == nameIndex.end())
    return 0;
>>>
    return = {
        value = (*i).second
        desc = node with the specified name, or 0 if no matching node is found
    }
}
function.protected[] = {
    spec = virtual
    type = void
    name = removeIndexEntry
    shortDesc = Remove index entry
    longDesc = Removes a child node info record from the name index.
    param[] = {
        type = const std::string&
        name = indexName
        desc = name to search for
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexName.size() == 0))
    return;
if ((indexMode == INDEX_MODE_TREE) && (parent != 0))
{
    parent->removeIndexEntry(indexName);
    return;
}
nameIndex[indexName] = 0;
NodeNameMap::iterator i = nameIndex.find(indexName);
if (i != nameIndex.end())
    nameIndex.erase(i);
>>>
}
function.protected[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = getIndexEntry
    const = true
    shortDesc = Get index entry
    longDesc = Retreives a child node info record by node ID.\
\
\note If a corresponding index entry is not found or the indexing mode is INDEX_MODE_NONE or \c indexID is negative, this function will return 0.
    param[] = {
        type = Ionflux::Template::NodeID
        name = indexID
        desc = ID to search for
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexID == ID_NOT_SET)
        || (indexID < 0))
        return 0;
    if ((indexMode == INDEX_MODE_TREE) && (parent != 0))
        return parent->getIndexEntry(indexID);
    /* ----- DEBUG ----- //
    cout << "Looking up ID index entry for " << indexID << "." << endl;
    // ----- DEBUG ----- */
    if (static_cast<unsigned int>(indexID) < idIndex.size())
        return idIndex[indexID];
>>>
    return = {
        value = 0
        desc = node with the specified node ID, or 0 if no matching node is found
    }
}
function.protected[] = {
    spec = virtual
    type = void
    name = removeIndexEntry
    shortDesc = Remove index entry
    longDesc = Removes a child node info record from the ID index.
    param[] = {
        type = Ionflux::Template::NodeID
        name = indexID
        desc = ID to search for
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexID == ID_NOT_SET)
    || (indexID < 0))
    return;
if ((indexMode == INDEX_MODE_TREE) && (parent != 0))
{
    parent->removeIndexEntry(indexID);
    return;
}
if (static_cast<unsigned int>(indexID) < idIndex.size())
    idIndex[indexID] = 0;
>>>
}
function.protected[] = {
    spec = virtual
    type = void
    name = removeIndexEntries
    shortDesc = Remove index entries
    longDesc = Removes a child node from all Indexes.
    param[] = {
        type = Ionflux::Template::Node*
        name = indexNode
        desc = node to be removed
    }
    impl = <<<
if ((indexMode == INDEX_MODE_NONE) || (indexNode == 0))
        return;
    removeIndexEntry(indexNode->getNodeName());
    removeIndexEntry(indexNode->getNodeID());
>>>
}

# Public member functions.
function.copy.impl = other.copy(*this);
function.public[] = {
    spec = virtual
    type = int
    name = addData
    shortDesc = Add data entry
    longDesc = Adds data to this node.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = const std::string&
        name = newData
        desc = Data to be added
    }
    impl = nodeData.push_back("");\
setData(getNumData() - 1, newData);
    return = {
        value = getNumData() - 1
        desc = The index of the data on success, -1 otherwise
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = addData
    shortDesc = Add data entry
    longDesc = Adds data to this node.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = int
        name = newData
        desc = Data to be added
    }
    impl = nodeData.push_back("");\
setData(getNumData() - 1, newData);
    return = {
        value = getNumData() - 1
        desc = The index of the data on success, -1 otherwise
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = addData
    shortDesc = Add data entry
    longDesc = Adds data to this node.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = double
        name = newData
        desc = Data to be added
    }
    impl = nodeData.push_back("");\
setData(getNumData() - 1, newData);
    return = {
        value = getNumData() - 1
        desc = The index of the data on success, -1 otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setBlob
    shortDesc = Set data entry
    longDesc = Sets value of data entry with specified index.\
\
\note This function will always set the data entry to the specified bytes, regardless of the node data type.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    param[] = {
        type = const std::string&
        name = newData
        desc = New value for data entry
    }
    impl = if (!validateDataIndex(dataIndex))\
    return false;\
nodeData[dataIndex] = newData;
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of data entry with specified index.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    param[] = {
        type = const std::string&
        name = newData
        desc = New value for data entry
    }
    impl = if (!validateDataIndex(dataIndex))\
    return false;\
if (dataType == DATA_INT)\
    return setData(dataIndex, \
        static_cast<int>(strtol(newData.c_str(), 0, 10)));\
if (dataType == DATA_DOUBLE)\
    return setData(dataIndex, strtod(newData.c_str(), 0));\
nodeData[dataIndex] = newData;
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of data entry with specified index.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    param[] = {
        type = int
        name = newData
        desc = New value for data entry
    }
    impl = if (dataType == DATA_DOUBLE)\
    return setData(dataIndex, static_cast<double>(newData));\
if (dataType == DATA_BLOB)\
\{\
    ostringstream newBlob;\
    newBlob << newData;\
    return setBlob(dataIndex, newBlob.str());\
\}\
std::string packed;\
Ionflux::ObjectBase::pack(newData, packed);
    return = {
        value = setBlob(dataIndex, packed);
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of data entry with specified index.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    param[] = {
        type = unsigned int
        name = newData
        desc = New value for data entry
    }
    impl = 
    return = {
        value = setData(dataIndex, static_cast<int>(newData))
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of data entry with specified index.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    param[] = {
        type = double
        name = newData
        desc = New value for data entry
    }
    impl = if (dataType == DATA_INT)\
    return setData(dataIndex, static_cast<int>(newData));\
if (dataType == DATA_BLOB)\
\{\
    ostringstream newBlob;\
    newBlob << newData;\
    return setBlob(dataIndex, newBlob.str());\
\}\
std::string packed;\
Ionflux::ObjectBase::pack(newData, packed);
    return = {
        value = setBlob(dataIndex, packed)
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of first data entry.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = const std::string&
        name = newData
        desc = New value for data entry
    }
    impl = 
    return = {
        value = setData(0, newData)
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of first data entry.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = int
        name = newData
        desc = New value for data entry
    }
    impl = 
    return = {
        value = setData(0, newData)
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of first data entry.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = unsigned int
        name = newData
        desc = New value for data entry
    }
    impl = 
    return = {
        value = setData(0, newData)
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = setData
    shortDesc = Set data entry
    longDesc = Sets value of first data entry.\
\
\note This function tries to convert as best as possible if the argument type does not match the node data type.
    param[] = {
        type = double
        name = newData
        desc = New value for data entry
    }
    impl = 
    return = {
        value = setData(0, newData)
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getData
    const = true
    shortDesc = Get data entry
    longDesc = Get data entry with specified index.\
\
\note If used with an INT or DOUBLE node, this returns the string representation of the number. If you want the exact binary representation, use getBlob() instead.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    impl = if (!validateDataIndex(dataIndex))\
    return "";\
if (dataType == DATA_INT)\
\{\
    ostringstream buf;\
    buf << getInt(dataIndex);\
    return buf.str();\
\} else\
if (dataType == DATA_DOUBLE)\
\{\
    ostringstream buf;\
    buf << getDouble(dataIndex);\
    return buf.str();\
\}
    return = {
        value = nodeData[dataIndex]
        desc = Data entry, or an empty string if entry with specified index does not exist
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getBlob
    const = true
    shortDesc = Get data entry
    longDesc = Get data entry with specified index.\
\
\note If used with an INT or DOUBLE node, this returns the binary representation of the number (in network byte order).
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    impl = if (!validateDataIndex(dataIndex))\
    return "";
    return = {
        value = nodeData[dataIndex]
        desc = Data entry, or an empty string if entry with specified index does not exist
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = getInt
    const = true
    shortDesc = Get data entry
    longDesc = Get data entry with specified index.\
\
\note If used with a BLOB node, using this may lead to unexpected behavior.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    impl = if (!validateDataIndex(dataIndex))\
    return 0;\
if (dataType == DATA_DOUBLE)\
    return static_cast<int>(getDouble(dataIndex));\
int result = 0;\
Ionflux::ObjectBase::unpack(nodeData[dataIndex], result);
    return = {
        value = result
        desc = Data entry, or 0 if entry with specified index does not exist
    }
}
function.public[] = {
    spec = virtual
    type = double
    name = getDouble
    const = true
    shortDesc = Get data entry
    longDesc = Get data entry with specified index.\
\
\note If used with a BLOB node, using this may lead to unexpected behavior.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    impl = if (!validateDataIndex(dataIndex))\
    return 0;\
if (dataType == DATA_INT)\
    return static_cast<double>(getInt(dataIndex));\
double result = 0;\
Ionflux::ObjectBase::unpack(nodeData[dataIndex], result);
    return = {
        value = result
        desc = Data entry, or 0 if entry with specified index does not exist
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = removeData
    shortDesc = Remove data entry
    longDesc = Remove data entry with specified index.
    param[] = {
        type = unsigned int
        name = dataIndex
        desc = Data index
    }
    impl = if (!validateDataIndex(dataIndex))\
    return false;\
vector<string>::iterator i = nodeData.begin();\
i += dataIndex;\
nodeData.erase(i);
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = clearData
    shortDesc = Remove all data entries
    longDesc = Remove all data entries from this node. Pass \c true to remove all data entries from child nodes recursively.
    param[] = {
        type = bool
        name = recursive
        desc = Whether to remove data entries of child nodes recursively
    }
    impl = if (recursive)\
\{\
    for (NodeVector::const_iterator i = children.begin(); \
        i != children.end(); i++)\
    \{\
        if ((*i) != 0)\
            (*i)->clearData(true);\
    \}\
\}\
nodeData.clear();
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = addChild
    shortDesc = Add a child
    longDesc = Creates a new child node and adds it to this node. The node thus created is managed by its parent node.\
\
\note By default, the new node will have the same data type, the same UID assignment mode and the same node auto-create mode as its parent.
    param[] = {
        type = Ionflux::Template::NodeID
        name = childID
        desc = ID of the new child node
        default = ID_NOT_SET
    }
    param[] = {
        type = const std::string&
        name = childName
        desc = Name of the new child node
        default = ""
    }
    impl = if (childID == ID_NOT_SET)\
\{\
    if (uidMode == UID_MODE_NODE)\
        childID = getUID(false);\
    else\
    if (uidMode == UID_MODE_TREE)\
        childID = getUID(true);\
\}\
Node* nc = new Node(this, childID, childName, dataType);\
if (nc == 0)\
    throw IFTemplateError("[Node::addChild] "\
        "Could not allocate node.");\
nc->setUidMode(uidMode);\
nc->setIndexMode(indexMode);\
nc->setAutoCreate(autoCreate);\
addLocalRef(nc);\
children.push_back(nc);\
nc->setParent(this);
    return = {
        value = nc
        desc = Pointer to the new child node
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = addChild
    shortDesc = Add a child
    longDesc = Adds a new child node to this node.
    param[] = {
        type = Ionflux::Template::Node*
        name = newChild
        desc = Child node to be added
    }
    impl = if (newChild == 0)\
    throw IFTemplateError("[Node::addChild] "\
        "Attempt to add null child.");\
addLocalRef(newChild);\
children.push_back(newChild);\
newChild->setParent(this);
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = findChild
    shortDesc = Find child node
    longDesc = Return a child by numerical ID.
    param[] = {
        type = int
        name = searchID
        desc = The ID of the child node to be returned
    }
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively through all child nodes
        default = false
    }
    param[] = {
        type = unsigned int
        name = level
        desc = search level
        default = 0
    }
    impl = <<<
Node* result = getIndexEntry(searchID);
if (result != 0)
    return result;
// Not in index, do a linear search.
NodeVector::const_iterator i = children.begin();
while ((result == 0) 
    && (i != children.end()))
{
    if (((*i) != 0) 
        && ((*i)->getNodeID() == searchID))
        result = *i;
    i++;
}
if (recursive 
    && (result == 0))
{
    i = children.begin();
    while ((result == 0) 
        && (i != children.end()))
    {
        if ((*i) != 0)
            result = (*i)->findChild(searchID, true, level + 1);
        i++;
    }
}
if (level == 0)
{
    // Query has been initiated at this node.
    if ((result == 0) 
        && autoCreate)
    {
        result = addChild();
        result->setNodeID(searchID);
    }
    // Update index. (This will do nothing if indexes are disabled.)
    if (result != 0)
        addIndexEntry(result);
}
>>>
    return = {
        value = result
        desc = Pointer to the first child node with the specified ID, or 0 if no child with the specified ID is found
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = findChild
    shortDesc = Find child node
    longDesc = Return a child by name.
    param[] = {
        type = const std::string&
        name = searchName
        desc = The name of the child node to be returned
    }
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively through all child nodes
        default = false
    }
    param[] = {
        type = unsigned int
        name = level
        desc = search level
        default = 0
    }
    impl = <<<
Node* result = getIndexEntry(searchName);
if (result != 0)
    return result;
// Not in index, do a linear search.
/* <---- DEBUG ----- //
std::cout << "[Node::findChild{" << nodeName << "}] "
    "DEBUG: Node not found in index, doing linear search." << std::endl;
// ----- DEBUG ----> */
NodeVector::const_iterator i = children.begin();
while ((result == 0) 
    && (i != children.end()))
{
    if (((*i) != 0) && (*i)->getNodeName() == searchName)
        result = *i;
    i++;
}
if (recursive 
    && (result == 0))
{
    i = children.begin();
    while ((result == 0) && (i != children.end()))
    {
        if ((*i) != 0)
            result = (*i)->findChild(searchName, true, level + 1);
        i++;
    }
}
if (level == 0)
{
    // Query has been initiated at this node.
    if ((result == 0)
        && autoCreate)
    {
        /* <---- DEBUG ----- //
        std::cout << "[Node::findChild{" << nodeName << "}] DEBUG: "
            "Node not found! Auto-creating a new node." << std::endl;
        // ----- DEBUG ----> */
        result = addChild();
        result->setNodeName(searchName);
    }
    // Update index. (This will do nothing if indexes are disabled.)
    if (result != 0)
        /* <---- DEBUG ----- //
        std::cout << "[Node::findChild{" << nodeName << "}] DEBUG: "
            "Adding node to index." << std::endl;
        // ----- DEBUG ----> */
        addIndexEntry(result);
}
>>>
    return = {
        value = result
        desc = Pointer to the first child node with the specified name, or 0 if no child with the specified name is found
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = findChild
    const = true
    shortDesc = Find child node
    longDesc = Return a child by numerical ID.
    param[] = {
        type = int
        name = searchID
        desc = The ID of the child node to be returned
    }
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively through all child nodes
        default = false
    }
    impl = Node *result = getIndexEntry(searchID);\
if (result != 0)\
    return result;\
// Not in index, do a linear search.\
NodeVector::const_iterator i = children.begin();\
while ((result == 0) \
    && (i != children.end()))\
\{\
    if (((*i) != 0) \
        && ((*i)->getNodeID() == searchID))\
        result = *i;\
    i++;\
\}\
if (recursive && (result == 0))\
\{\
    i = children.begin();\
    while ((result == 0) \
        && (i != children.end()))\
    \{\
        if ((*i) != 0)\
            result = (*i)->findChild(searchID, true);\
        i++;\
    \}\
\}
    return = {
        value = result
        desc = Pointer to the first child node with the specified ID, or 0 if no child with the specified ID is found
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = findChild
    const = true
    shortDesc = Find child node
    longDesc = Return a child by name.
    param[] = {
        type = const std::string&
        name = searchName
        desc = The name of the child node to be returned
    }
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively through all child nodes
        default = false
    }
    impl = Node *result = getIndexEntry(searchName);\
if (result != 0)\
    return result;\
// Not in index, do a linear search.\
NodeVector::const_iterator i = children.begin();\
while ((result == 0) \
    && (i != children.end()))\
\{\
    if (((*i) != 0) && (*i)->getNodeName() == searchName)\
        result = *i;\
    i++;\
\}\
if (recursive && (result == 0))\
\{\
    i = children.begin();\
    while ((result == 0) && (i != children.end()))\
    \{\
        if ((*i) != 0)\
            result = (*i)->findChild(searchName, true);\
        i++;\
    \}\
\}
    return = {
        value = result
        desc = Pointer to the first child node with the specified name, or 0 if no child with the specified name is found
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = getChild
    const = true
    shortDesc = Get child node
    longDesc = Get child node with specified index.
    param[] = {
        type = unsigned int
        name = childIndex
        desc = Index of the child node to be returned
    }
    impl = if (!validateChildIndex(childIndex))\
    return 0;
    return = {
        value = children[childIndex]
        desc = Pointer to the child node with the specified ID, or 0 if no child with the specified ID is found
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = removeChild
    shortDesc = Remove child node
    longDesc = Remove a child node from this node.
    param[] = {
        type = unsigned int
        name = childIndex
        desc = Index of the child node to be removed
    }
    impl = if ((childIndex < 0) || (childIndex >= children.size()))\
    return false;\
NodeVector::iterator i = children.begin();\
i += childIndex;\
if ((*i) == 0)\
    throw IFTemplateError("[Node::removeChild] "\
        "Child node pointer is null.");\
removeLocalRef(*i);\
children.erase(i);
    return = {
        value = true
        desc = \c true if the specified node has been deleted successfully, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = removeChild
    shortDesc = Remove child node
    longDesc = Remove a child node from this node. Pass \c true to recursively try to remove the specified node.
    param[] = {
        type = Ionflux::Template::Node*
        name = targetNode
        desc = Child node to be removed
    }
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively for the node
        default = false
    }
    impl = if ((targetNode == 0) || (children.size() == 0))\
    return false;\
NodeVector::iterator i = children.begin();\
bool found = false;\
while ((i != children.end()) \
    && !found)\
\{\
    if ((*i) == targetNode)\
        found = true;\
    else\
        i++;\
\}\
if (found)\
\{\
    if ((*i) == 0)\
        throw IFTemplateError("[Node::removeChild] "\
            "Child node pointer is null.");\
    removeLocalRef(*i);\
    children.erase(i);\
\} else\
if (recursive)\
\{\
    i = children.begin();\
    while ((i != children.end()) \
        && !found)\
        if ((*i) != 0)\
            found = (*i)->removeChild(targetNode, true);\
\}
    return = {
        value = found
        desc = \c true if the specified node has been deleted successfully, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = removeAllChildren
    shortDesc = Remove all child nodes
    longDesc = Remove all child nodes from this node. Pass \c true to recursively remove all child nodes.
    param[] = {
        type = bool
        name = recursive
        desc = Whether to remove child nodes recursively
        default = false
    }
    impl = <<<
/* <---- DEBUG ----- //
std::cerr << "[" << getIDString() << "::removeAllChildren] DEBUG: "
    << "Removing all children." << std::endl;
// ----- DEBUG ----> */
NodeVector::iterator i;
for (i = children.begin(); i != children.end(); i++)
{
    if ((*i) != 0)
    {
        if (recursive)
            (*i)->removeAllChildren(true);
        removeIndexEntries(*i);
        removeLocalRef(*i);
    } else
        throw IFTemplateError("[Node::removeAllChildren] "
            "Child node pointer is null.");
}
nameIndex.clear();
idIndex.clear();
children.clear();
>>>
}
function.public[] = {
    spec = virtual
    type = bool
    name = setChild
    shortDesc = Set child node
    longDesc = Set a child node to a specified node.
    param[] = {
        type = unsigned int
        name = childIndex
        desc = Index of the child node to be set
    }
    param[] = {
        type = Ionflux::Template::Node*
        name = newChild
        desc = Node to be set as child node
    }
    impl = if (newChild == 0)\
    throw IFTemplateError("[Node::setChild] "\
        "Attempt to set null child.");\
if (!validateChildIndex(childIndex))\
    return 0;\
addLocalRef(newChild);\
Node* currentNode = children[childIndex];\
if (currentNode != 0)\
    removeLocalRef(currentNode);\
children[childIndex] = newChild;
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = getChildIndex
    shortDesc = Get child node index
    longDesc = Get the index of a child node.
    param[] = {
        type = Ionflux::Template::Node*
        name = targetNode
        desc = Child node
    }
    impl = if (targetNode == 0)\
    throw IFTemplateError("[Node::setChild] "\
        "Target node is null.");\
unsigned int result = 0;\
bool found = false;\
while ((result < children.size()) \
    && !found)\
\{\
    if (children[result] == targetNode)\
        found = true;\
    else\
        result++;\
\}\
if (!found)\
    return -1;
    return = {
        value = result
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = printDebugInfo
    shortDesc = Print debug information
    longDesc = Prints debug information for child nodes belonging to a certain tree depth level.
    param[] = {
        type = int
        name = targetLevel
        desc = The tree depth level for which debugging information should be printed
    }
    param[] = {
        type = int
        name = callingLevel
        desc = The tree depth level of the calling node
    }
    param[] = {
        type = int
        name = parentID
        desc = The child ID of the calling node
    }
    param[] = {
        type = int
        name = childID
        desc = The child ID of this node
    }
    impl = callingLevel++;\
// callingLevel is now actually the tree depth level of this node.\
if (targetLevel == callingLevel)\
\{\
    std::cout << "Node " << parentID << ":" << childID << " (level " \
        << targetLevel << "):" << std::endl;\
    std::cout << "(this: " << this << ", parent: " << parent << ")" \
        << std::endl;\
    std::cout << "Name: " << nodeName << std::endl;\
    std::cout << "ID:   " << nodeID << std::endl;\
    std::cout << "Data:" << std::endl;\
    if (nodeData.size() == 0)\
        std::cout << "(empty)" << std::endl;\
    string currentData;\
    for (unsigned int i = 0; i < nodeData.size(); i++)\
    \{\
        currentData = getBlob(i);\
        std::cout << "[" << i << "]:" << std::endl \
            << Ionflux::ObjectBase::makeNiceHex(\
                Ionflux::ObjectBase::makeHex(currentData), \
                Ionflux::ObjectBase::makeReadable(currentData, "."), \
                16, 8);\
    \}\
    std::cout << std::endl;\
    return 1;\
\}\
int result = 0;\
// If this node didn't belong to target level, try the child nodes.\
for (unsigned int i = 0; i < children.size(); i++)\
\{\
    if (children[i] != 0)\
        result += children[i]->printDebugInfo(targetLevel, \
            callingLevel, childID, i);\
\}
    return = {
        value = result
        desc = Number of nodes of the specified tree depth
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = printDebugInfo
    shortDesc = Print debug information
    longDesc = Prints debug information for child nodes belonging to a certain tree depth level, while this node is assumed to be the root node.
    param[] = {
        type = int
        name = targetLevel
        desc = The tree depth level for which debugging information should be printed
    }
    impl = 
    return = {
        value = printDebugInfo(targetLevel, -1, 0, 0);
        desc = Number of nodes of the specified tree depth
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = getUID
    shortDesc = Get unique ID
    longDesc = Gets a unique ID (UID) for this node. The return value will be unique to this node if \c false is passed and unique to the whole tree if \c true is passed.
    param[] = {
        type = bool
        name = treeUID
        desc = Whether the UID should be unique to the whole tree
    }
    impl = if (!treeUID || (parent == 0))\
\{\
    maxUID++;\
    return maxUID;\
\}
    return = {
        value = parent->getUID(true)
        desc = Unique ID
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = traverse
    shortDesc = Traverse sub-tree
    longDesc = Traverse the sub-tree starting at this node, in the specified order.
    param[] = {
        type = Ionflux::Template::NodeDump*
        name = target
        desc = Target to pass nodes to
    }
    param[] = {
        type = Ionflux::Template::NodeTraversalMode
        name = order
        desc = Order of traversal
    }
    impl = NodeVector::const_iterator i;\
switch (order)\
\{\
    case TRAVERSAL_INORDER:\
        if (getNumChildren() == 2)\
        \{\
            Node *leftChild = getChild(0);\
            Node *rightChild = getChild(1);\
            if (leftChild != 0)\
                leftChild->traverse(target, order);\
            if (target != 0)\
                target->dump(this);\
            if (rightChild != 0)\
                rightChild->traverse(target, order);\
        \} else\
            throw IFTemplateError("[Node::traverse] "\
                "Invalid traversal order for non-binary tree.");\
        break;\
    case TRAVERSAL_PREORDER:\
        if (target != 0)\
            target->dump(this);\
        for (i = children.begin(); i != children.end(); i++)\
            if ((*i) != 0)\
                (*i)->traverse(target, order);\
        break;\
    case TRAVERSAL_POSTORDER:\
        for (i = children.begin(); i != children.end(); i++)\
            if ((*i) != 0)\
                (*i)->traverse(target, order);\
        if (target != 0)\
            target->dump(this);\
        break;\
    default:\
        throw IFTemplateError("[Node::traverse] "\
            "Invalid traversal order.");\
\}
}
function.public[] = {
    spec = virtual
    type = void
    name = serialize
    shortDesc = Serialize sub-tree
    longDesc = Serialize the sub-tree starting at this node. Any data resulting from the serialization will be appended to the target byte string.\
\
\note See misc/node-serialization.txt for a description of the serialization format.\
\
\sa unpack()
    param[] = {
        type = std::string&
        name = target
        desc = Where to store the serialized sub-tree
    }
    impl = ostringstream status;\
string nodeBlock;\
// Reserve 24 bytes for later addition of size and checksum.\
nodeBlock.append(24, '\x00');\
// Append node header.\
Ionflux::ObjectBase::pack(static_cast<int32_t>(nodeID), nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<int32_t>(dataType), nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<int32_t>(maxUID), nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<int32_t>(uidMode), nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<uint8_t>(autoCreate), nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<uint32_t>(getNumData()), \
    nodeBlock);\
Ionflux::ObjectBase::pack(static_cast<uint32_t>(getNumChildren()), \
    nodeBlock);\
// Append node name block.\
Ionflux::ObjectBase::pack(static_cast<uint32_t>(nodeName.size()), \
    nodeBlock);\
nodeBlock.append(nodeName);\
// Append data entries.\
for (unsigned int i = 0; i < nodeData.size(); i++)\
\{\
    Ionflux::ObjectBase::pack(static_cast<uint32_t>(nodeData[i].size()), \
        nodeBlock);\
    nodeBlock.append(nodeData[i]);\
\}\
// Append child node data blocks.\
Node *currentChild;\
for (unsigned int i = 0; i < children.size(); i++)\
\{\
    currentChild = children[i];\
    if (currentChild != 0)\
        currentChild->serialize(nodeBlock);\
    else\
        target.append(1, '\x00');\
\}\
// Add block size.\
/* <---- DEBUG ----- //\
status.str("");\
status << "[Node::serialize] DEBUG: "\
    "Node block size: " << nodeBlock.size() << " bytes.";\
std::cout << status.str() << std::endl;\
// ----- DEBUG ----> */\
std::string packed;\
Ionflux::ObjectBase::pack(static_cast<uint32_t>(nodeBlock.size()), \
    packed);\
nodeBlock.replace(0, 4, packed);\
// Add checksum.\
std::string checkSum = Ionflux::ObjectBase::sha1(nodeBlock);\
nodeBlock.replace(4, 20, checkSum);\
/* <---- DEBUG ----- //\
status.str("");\
status << "[Node::serialize] DEBUG: "\
    "SHA-1 Checksum: " << Ionflux::ObjectBase::makeHex(checkSum);\
std::cout << status.str() << std::endl;\
// ----- DEBUG ----> */\
target.append(nodeBlock);
}
function.public[] = {
    spec = virtual
    type = bool
    name = unpack
    shortDesc = Unpack sub-tree
    longDesc = Unpack the sub-tree starting at this node. This will delete all data and remove all children currently in this node. Data extraction begins at 'blockStart' and at most 'blockSize' bytes will be used for unpacking nodes. If you pass 0 as the block size, the block size will be set to the size of the serialized input.\
\
\note See misc/node-serialization.txt for a description of the serialization format.\
\
\sa unpack()
    param[] = {
        type = const std::string&
        name = serialized
        desc = Sub-Tree in serialized form
    }
    param[] = {
        type = unsigned int
        name = blockStart
        desc = Position in the serialized data where the block to be unpacked starts
    }
        param[] = {
        type = unsigned int
        name = blockSize
        desc = Size of the block to be unpacked
    }
    impl = <<<
if (blockSize == 0)
    blockSize = serialized.size();
if ((blockStart + blockSize) > serialized.size())
{
    throw IFTemplateError("[Node::unpack] "
        "Block size mismatch: Serialized data "
        "block smaller than specified block size.");
    return false;
}
if (blockSize < HEADER_SIZE)
{
    throw IFTemplateError("[Node::unpack] "
        "Block size mismatch: Specified block "
        "size smaller than size of node header.");
    return false;
}
std::ostringstream status;
unsigned int currentPos = blockStart;
// Validate node block size.
unsigned int nodeBlockSize = unpackInt(serialized.substr(currentPos, 4));
/* <---- DEBUG ----- //
std:cerr << "[Node::unpack] DEBUG: Node block size: " << nodeBlockSize 
    << " bytes." << std::endl;
// ----- DEBUG ----> */
if (blockSize < nodeBlockSize)
{
    throw IFTemplateError("[Node::unpack] "
        "Block size mismatch: Serialized data "
        "block smaller than node block size.");
}
// Extract node data block.
string nodeBlock = serialized.substr(currentPos, nodeBlockSize);
currentPos = 4;
// Validate checksum.
string checkSum = nodeBlock.substr(currentPos, 20);
string emptyCheckSum(20, '\x00');
/* <---- DEBUG ----- //
std::cerr << "[Node::unpack] DEBUG: Node block SHA-1 extracted "
    "checksum:  " << Ionflux::ObjectBase::makeHex(checkSum) 
    << std::endl;
// ----- DEBUG ----> */
nodeBlock.replace(currentPos, 20, emptyCheckSum);
string calcCheckSum = Ionflux::ObjectBase::sha1(
    nodeBlock.substr(0, nodeBlockSize));
/* <---- DEBUG ----- //
std::cerr << "[Node::unpack] DEBUG: Node block SHA-1 calculated "
    "checksum: " + Ionflux::ObjectBase::makeHex(calcCheckSum) 
    << std::endl;
// ----- DEBUG ----> */
if (checkSum != calcCheckSum)
{
    throw IFTemplateError("[Node::unpack] "
        "Checksum mismatch: The node data block "
        "is probably corrupted.");
    return false;
}
/* <---- DEBUG ----- //
std::cerr << "[Node::unpack] DEBUG: Checksum OK. :-)" << std::endl;
// ----- DEBUG ----> */
currentPos += 20;
// Extract header fields.
/* <---- DEBUG ----- //
log->msg("[Node::unpack] DEBUG: Extracting node header data.", 
    log->VL_DEBUG_INSANE);
// ----- DEBUG ----> */
clear();
/* <---- DEBUG ----- //
status.str("");
status << "[Node::unpack] DEBUG: Extracted header data: ";
// ----- DEBUG ----> */
setNodeID(unpackInt(nodeBlock.substr(currentPos, 4)));
/* <---- DEBUG ----- //
status << "nodeID = " << getID() << ", ";
// ----- DEBUG ----> */
currentPos += 4;
setDataType(unpackInt(nodeBlock.substr(currentPos, 4)));
/* <---- DEBUG ----- //
status << "dataType = " << getDataType() << ", ";
// ----- DEBUG ----> */
currentPos += 4;
maxUID = unpackInt(nodeBlock.substr(currentPos, 4));
/* <---- DEBUG ----- //
status << "maxUID = " << maxUID << ", ";
// ----- DEBUG ----> */
currentPos += 4;
setUidMode(unpackInt(nodeBlock.substr(currentPos, 4)));
/* <---- DEBUG ----- //
status << "uidMode = " << getUIDMode() << ", ";
// ----- DEBUG ----> */
currentPos += 4;
setAutoCreate(unpackBool(nodeBlock.substr(currentPos, 1)));
/* <---- DEBUG ----- //
status << "autoCreate = " << getAutoCreate() << ", ";
// ----- DEBUG ----> */
currentPos++;
unsigned int numData = unpackInt(nodeBlock.substr(currentPos, 4));
/* <---- DEBUG ----- //
status << "numData = " << numData << ", ";
// ----- DEBUG ----> */
currentPos += 4;
unsigned int numChildren = unpackInt(nodeBlock.substr(currentPos, 4));
/* <---- DEBUG ----- //
status << "numChildren = " << numChildren << ", ";
// ----- DEBUG ----> */
currentPos += 4;
unsigned int nameSize = unpackInt(nodeBlock.substr(currentPos, 4));
/* <---- DEBUG ----- //
status << "nameSize = " << nameSize << ", ";
// ----- DEBUG ----> */
currentPos += 4;
setNodeName(nodeBlock.substr(currentPos, nameSize));
/* <---- DEBUG ----- //
status << "nodeName = '" << getName() << "'.";
// ----- DEBUG ----> */
currentPos += nameSize;
/* <---- DEBUG ----- //
log->msg(status.str(), log->VL_DEBUG_INSANE);
if (numData > 0)
    log->msg("[Node::unpack] DEBUG: Extracting data entries.", 
        log->VL_DEBUG_INSANE);
// ----- DEBUG ----> */
// Extract data.
unsigned int dataSize;
string dataBytes;
for (unsigned int i = 0; i < numData; i++)
{
    dataSize = unpackInt(nodeBlock.substr(currentPos, 4));
    currentPos += 4;
    if (dataSize > 0)
        dataBytes = nodeBlock.substr(currentPos, dataSize);
    else
        dataBytes = "";
    setBlob(i, dataBytes);
    /* <---- DEBUG ----- //
    status.str("");
    status << "[Node::unpack] DEBUG: Data entry [" << i 
        << "]: size = " << dataSize << ", value = " 
        << makeHex(getData(i));
    log->msg(status.str(), log->VL_DEBUG_INSANE);
    // ----- DEBUG ----> */
    currentPos += dataSize;
}
// Extract child nodes.
/* <---- DEBUG ----- //
if (numChildren > 0)
    log->msg("[Node::unpack] DEBUG: Extracting child nodes.", 
        log->VL_DEBUG_INSANE);
// ----- DEBUG ----> */
Node *currentChild;
unsigned int childBlockSize;
unsigned int childCount = 0;
bool unpackOK = true;
while((childCount < numChildren) && unpackOK)
{
    childBlockSize = unpackInt(nodeBlock.substr(currentPos, 4));
    /* <---- DEBUG ----- //
    status.str("");
    status << "[Node::unpack] DEBUG: Child node [" << childCount 
        << "]: blockSize = " << childBlockSize;
    log->msg(status.str(), log->VL_DEBUG_INSANE);
    // ----- DEBUG ----> */
    if (childBlockSize == 0)
    {
        /* <---- DEBUG ----- //
        log->msg("[Node::unpack] DEBUG: Adding child node (null).", 
            log->VL_DEBUG_INSANE);
        // ----- DEBUG ----> */
        addChild(Node::create());
        currentPos += 4;
    } else
    {
        /* <---- DEBUG ----- //
        log->msg("[Node::unpack] DEBUG: Unpacking child node.", 
            log->VL_DEBUG_INSANE);
        // ----- DEBUG ----> */
        currentChild = addChild();
        unpackOK = currentChild->unpack(nodeBlock, currentPos, 
            childBlockSize);
        if (unpackOK)
        {
            /* <---- DEBUG ----- //
            log->msg("[Node::unpack] DEBUG: Child node unpacked "
                "successfully.", log->VL_DEBUG_INSANE);
            // ----- DEBUG ----> */
        } else
        {
            status.str("");
            status << "[Node::unpack] Child node [" << childCount 
                << "]: Unpacking failed!";
            throw IFTemplateError(status.str());
        }
        currentPos += childBlockSize;
    }
    childCount++;
}
/* <---- DEBUG ----- //
log->msg("[Node::unpack] DEBUG: Unpacking finished.", log->VL_DEBUG_INSANE);
if (!unpackOK)
    log->msg("[Node::unpack] DEBUG: Some child nodes could not be "
        "unpacked.", log->VL_DEBUG_INSANE);
// ----- DEBUG ----> */
>>>
    return = {
        value = unpackOK
        desc = \c true if the data is successfully unpacked, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = convertToNativeType
    shortDesc = Convert node to native data type
    longDesc = Converts the node to the data type best suited for representing its data. This is accomplished by checking the first data entry and converting all data entries to the new type.\
\
\note This only applies to nodes of type Node::DATA_BLOB. For other data types, it is assumed that the data type is already optimal to represent the data contained in the node.
    impl = <<<
if (dataType != DATA_BLOB)
        return;
    string data = getBlob();
    if (Ionflux::ObjectBase::isInteger(data))
    {
        setDataType(DATA_INT);
        int intData;
        for (unsigned int i = 0; i < getNumData(); i++)
        {
            data = getBlob(i);
            intData = strtol(data.c_str(), 0, 10);
            setData(i, intData);
        }
    } else
    if (Ionflux::ObjectBase::isFloat(data))
    {
        setDataType(DATA_DOUBLE);
        for (unsigned int i = 0; i < getNumData(); i++)
        {
            data = getBlob(i);
            setData(i, strtod(data.c_str(), 0));
        }
    }
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = clearNameIndex
    shortDesc = Clear name index
    longDesc = Clear the child node by name index.
    impl = nameIndex.clear();
}
function.public[] = {
    spec = virtual
    type = void
    name = clearIDIndex
    shortDesc = Clear ID index
    longDesc = Clear the child node by ID index.
    impl = idIndex.clear();
}
function.public[] = {
    spec = virtual
    type = void
    name = clearIndexes
    shortDesc = Clear all indexes
    longDesc = Clear all indexes.
    impl = clearNameIndex();\
clearIDIndex();
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node*
    name = copy
    const = true
    shortDesc = Copy
    longDesc = Copy the node to a specified target node. Child nodes will be copied recursively up to the maximum depth specified, or to the maximum possible depth if no maximum depth is specified.
    param[] = {
        type = Ionflux::Template::Node&
        name = target
        desc = Target for the copy
    }
    param[] = {
        type = unsigned int
        name = maxDepth
        desc = Maximum recursion depth
        default = 0
    }
    param[] = {
        type = unsigned int
        name = currentDepth
        desc = Depth of current node
        default = 0
    }
    impl = <<<
if (&target == this)
    return &target;
bool origAutoCreate = getAutoCreate();
Node* currentChild = 0;
Node* currentSourceChild = 0;
// Clear the node.
target.clearData(false);
target.removeAllChildren(false);
target.setDataType(getDataType());
target.setUidMode(getUidMode());
// NOTE: Why is maxUID reset here?
//maxUID = getUID(false);
// Set auto-create for copying data entries and child nodes.
target.setAutoCreate(true);
// Copy data entries.
for (unsigned int i = 0; i < getNumData(); i++)
    target.setBlob(i, getBlob(i));
if ((maxDepth > 0)
    && (currentDepth >= maxDepth))
{
    target.setAutoCreate(origAutoCreate);
    return &target;
}
// Copy child nodes.
for (unsigned int i = 0; i < getNumChildren(); i++)
{
    currentSourceChild = getChild(i);
    if (currentSourceChild != 0)
    {
        currentChild = target.addChild();
        /* <---- DEBUG ----- //
        std::cerr << "[Node::copy] DEBUG: "
            "Created node " << currentChild << std::endl;
        // ----- DEBUG ----> */
        // Name and ID must be set explicitly.
        currentChild->setNodeName(currentSourceChild->getNodeName());
        currentChild->setNodeID(currentSourceChild->getNodeID());
        currentSourceChild->copy(*currentChild, maxDepth, 
            currentDepth + 1);
    }
}
target.setAutoCreate(origAutoCreate);
>>>
    return = {
        value = &target
        desc = target node
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node&
    name = operator[]
    shortDesc = Find child node
    longDesc = Return a child by numerical ID.\
\
\note This will always create non-existent nodes, even with auto-create turned off. If you do not want this, you should not use subscripting, but findChild() instead. Also be aware that you cannot use subscription operators to access data fields in your code, while this is possible if you use subscripting in tree path expressions which are parsed at run-time. Use getData() or parsed tree paths if you want to access data entries in your source.\
\
\sa findChild(), getData()
    param[] = {
        type = int
        name = searchID
        desc = The ID of the child node to be returned
    }
    impl = <<<
bool lastAutoCreate = getAutoCreate();
setAutoCreate(true);
Node *result = findChild(searchID, false);
setAutoCreate(lastAutoCreate);
>>>
    return = {
        desc = First child node with specified ID, or a newly created node with that ID
        value = *result
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node&
    name = operator[]
    shortDesc = Find child node
    longDesc = Return a child by name.\
\
\note This will always create non-existent nodes, even with auto-create turned off. If you do not want this, you should not use subscripting, but findChild() instead. Also be aware that you cannot use subscription operators to access data fields in your code, while this is possible if you use subscripting in tree path expressions which are parsed at run-time. Use getData() or parsed tree paths if you want to access data entries in your source.\
\
\sa findChild(), getData()
    param[] = {
        type = const std::string&
        name = searchName
        desc = The name of the child node to be returned
    }
    impl = <<<
bool lastAutoCreate = getAutoCreate();
setAutoCreate(true);
Node *result = findChild(searchName, false);
setAutoCreate(lastAutoCreate);
>>>
    return = {
        desc = First child node with specified name, or a newly created node with that ID
        value = *result
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = operator=
    shortDesc = Assign value to data entry
    longDesc = Assigns a value to the first data entry.
    param[] = {
        type = const std::string&
        name = newData
        desc = New value for data entry
    }
    impl = setData(0, newData);
    return = {
        desc = New value of the first data entry
        value = newData
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = operator=
    shortDesc = Assign value to data entry
    longDesc = Assigns a value to the first data entry.
    param[] = {
        type = int
        name = newData
        desc = New value for data entry
    }
    impl = setData(0, newData);
    return = {
        desc = New value of the first data entry
        value = newData
    }
}
function.public[] = {
    spec = virtual
    type = double
    name = operator=
    shortDesc = Assign value to data entry
    longDesc = Assigns a value to the first data entry.
    param[] = {
        type = double
        name = newData
        desc = New value for data entry
    }
    impl = setData(0, newData);
    return = {
        desc = New value of the first data entry
        value = newData
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getData
    const = true
    shortDesc = Get data
    longDesc = Get data entry at index 0.
    impl = 
    return = {
        desc = Data entry at index 0
        value = getData(0)
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getBlob
    const = true
    shortDesc = Get data as blob
    longDesc = Get data entry at index 0.
    impl = 
    return = {
        desc = Data entry at index 0
        value = getBlob(0)
    }
}
function.public[] = {
    spec = virtual
    type = int
    name = getInt
    const = true
    shortDesc = Get data as integer
    longDesc = Get data entry at index 0.
    impl = 
    return = {
        desc = Data entry at index 0
        value = getInt(0)
    }
}
function.public[] = {
    spec = virtual
    type = double
    name = getDouble
    const = true
    shortDesc = Get data as double
    longDesc = Get data entry at index 0.
    impl = 
    return = {
        desc = Data entry at index 0
        value = getDouble(0)
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = getNumData
    const = true
    shortDesc = Get number of data entries
    longDesc = Get the number of data entries.
    impl = 
    return = {
        desc = Number of data entries
        value = nodeData.size()
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = getNumChildren
    const = true
    shortDesc = Get number of children
    longDesc = Return the number of children of this node. Pass \c true to retrieve the number of children recursively.
    param[] = {
        type = bool
        name = recursive
        desc = Whether to search recursively through all child nodes
        default = false
    }
    impl = unsigned int result = children.size();\
if (recursive)\
\{\
    NodeVector::const_iterator i;\
    for (i = children.begin(); i != children.end(); i++)\
    \{\
        if ((*i) != 0) \
            result += (*i)->getNumChildren(true);\
    \}\
\}
    return = {
        value = result
        desc = Number of child nodes
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getPath
    shortDesc = Get tree path
    longDesc = Get the fully qualified tree path from the root node to this node.\
\
\note If a node in the path has a name, that name will be used in the tree path expression with the resolution operator. If a node has no name, but an ID, the ID will be used in the tree path expression using subscripting.
    impl = <<<
std::string result;
if (parent != 0)
{
    result = parent->getPath();
    if (nodeName != "")
    {
        /* Append resolution operator only if this node is not a child of
           the root node. */
        if (result != "")
           result.append(".");
        result.append(nodeName);
    } else
    if (nodeID != ID_NOT_SET)
    {
        /* Use subscripting for IDs. (Resolution operator could be used 
           as well.) */
        ostringstream status;
        status << "[" << nodeID << "]";
        result.append(status.str());
    } else
    {
        throw IFTemplateError("[Node::getPath] "
            "Unable to create path for unnamed "
            "node without ID.");
    }
}
>>>
    return = {
        desc = Fully qualified tree path expression
        value = result
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = clear
    shortDesc = Clear
    longDesc = Clear the node.
    impl = clearData(false);\
removeAllChildren(false);
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::Node&
    name = merge
    shortDesc = Merge nodes
    longDesc = Merges data entries and child nodes of the source node into the node.\
\
\note The name and ID of each source child node will be checked against names and IDs child nodes of the source node. If \c replace is \c false or omitted, child nodes of the target node will not be replaced by child nodes of the source node if names or IDs are equal.
    param[] = {
        type = Ionflux::Template::Node&
        name = sourceNode
        desc = Node which should be merged
    }
    param[] = {
        type = bool
        name = replace
        desc = Whether child nodes in the target node should be replaced by child nodes from the source node
        default = false
    }
    param[] = {
        type = unsigned int
        name = maxDepth
        desc = Maximum recursion depth
        default = 0
    }
    param[] = {
        type = unsigned int
        name = currentDepth
        desc = Depth of current node
        default = 0
    }
    impl = <<<
bool origAutoCreate = getAutoCreate();
// Merge data entries.
setAutoCreate(true);
unsigned int targetNumData = getNumData();
unsigned int sourceNumData = sourceNode.getNumData();
for (unsigned int i = 0; i < sourceNumData; i++)
    setBlob(targetNumData + i, sourceNode.getBlob(i));
if ((maxDepth > 0)
    && (currentDepth >= maxDepth))
{
    setAutoCreate(origAutoCreate);
    return *this;
}
// Merge child nodes.
setAutoCreate(false);
Node *currentChild = 0;
Node *currentSourceChild = 0;
string srcChildName;
int srcChildID;
bool merge;
for (unsigned int i = 0; i < sourceNode.getNumChildren(); i++)
{
    currentSourceChild = sourceNode.getChild(i);
    if (currentSourceChild != 0)
    {
        merge = true;
        srcChildID = currentSourceChild->getNodeID();
        srcChildName = currentSourceChild->getNodeName();
        if (srcChildID != ID_NOT_SET)
        {
            // Source child node has an ID.
            currentChild = findChild(srcChildID);
            if (replace && (currentChild != 0))
                // Child node with same ID exists, replace it.
                removeChild(currentChild, false);
            else
            if (currentChild != 0)
                // Child node with same ID exists.
                merge = false;
        }
        if (srcChildName.size() > 0)
        {
            // Source child node is a named node.
            currentChild = findChild(srcChildName);
            if (replace && (currentChild != 0))
                // Child node with same name exists, replace it.
                removeChild(currentChild, false);
            else
            if (currentChild != 0)
                // Child node with same name exists.
                merge = false;
        }
        if (merge)
        {
            // Merge source child node.
            currentChild = addChild();
            currentChild->setNodeName(currentSourceChild->getNodeName());
            currentChild->setNodeID(currentSourceChild->getNodeID());
            currentSourceChild->copy(*currentChild, maxDepth, 
                currentDepth + 1);
        }
    }
}
setAutoCreate(origAutoCreate);
>>>
    return = {
        value = *this
        desc = Merged node
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = combine
    shortDesc = Combine items
    longDesc = Combines each data entry of a first level child node (called a class of items) with data entries from the other first level child nodes (classes). Only nodes in the range \c from up to (and including) \c to will be used for combination. The result is stored in \c target, with each first level node containing a unique combination of items as its data entries.
    param[] = {
        type = unsigned int
        name = from
        desc = Start of range
    }
    param[] = {
        type = unsigned int
        name = to
        desc = End of range
    }
    param[] = {
        type = Ionflux::Template::Node&
        name = target
        desc = Target node
    }
    impl = <<<
if (from > to)
    return false;
target.clear();
bool origAutoCreate = target.getAutoCreate();
target.setAutoCreate(true);
Node *currentClass;
currentClass = getChild(from);
if (currentClass == 0)
    return false;
if (from == to)
{
    // Nothing to combine, return entries of current class.
    for (unsigned int i = 0; i < currentClass->getNumData(); i++)
        target[i].setData(0, currentClass->getData(i));
} else
{
    // Combine recursively.
    Node temp;
    Node *currentSubCmb;
    unsigned int currentCmb = 0;
    string currentItem;
    combine(from + 1, to, temp);
    /* Combine each item of the current class with the combinations of 
       the other classes. */
    for (unsigned int i = 0; i < currentClass->getNumData(); i++)
    {
        currentItem = currentClass->getData(i);
        for (unsigned int k = 0; k < temp.getNumChildren(); k++)
        {
            currentSubCmb = temp.getChild(k);
            if (currentSubCmb == 0)
                return false;
            target[currentCmb].setData(0, currentItem);
            for (unsigned int l = 0; l < currentSubCmb->getNumData(); l++)
                target[currentCmb].setData(l + 1, 
                    currentSubCmb->getData(l));
            currentCmb++;
        }
    }
}
target.setAutoCreate(origAutoCreate);
>>>
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = std::string
    name = toConfig
    shortDesc = Get configuration file representation
    longDesc = Create a representation of the node (and its children) suitable for insertion into a config file, using the extended (nested) syntax.\
\
\note The configuration file representation is human-readable and editable in any text editor. It may consist of multiple lines.
    param[] = {
        type = const std::string&
        name = indent
        desc = Use this string to indent the lines of the string representation
        default = "  "
    }
    param[] = {
        type = unsigned int
        name = level
        desc = The indentation level
        default = 0
    }
    impl = <<<
std::ostringstream status;
string levelIndent;
if (level >= 1)
    for (unsigned int i = 0; i < (level - 1); i++)
        levelIndent.append(indent);
bool nestedContext = false;
if ((nodeName == "<root>")
    || (level == 0))
    nestedContext = false;
else
if (nodeName.size() > 0)
{
    // Named node (but not the root node).
    status << levelIndent;
    if (Ionflux::ObjectBase::isIdentifier(nodeName))
        // Simple name (identifier).
        status << nodeName << " = ";
    else
        // Complex name, use subscript.
        status << "[\"" << Ionflux::ObjectBase::escape(nodeName, "\"") 
            << "\"] = ";
    nestedContext = true;
} else
if (nodeID != ID_NOT_SET)
{
    // Unnamed node, use ID.
    status << levelIndent;
    status << "[" << nodeID << "] = ";
    nestedContext = true;
    // NOTE: If this fails, too, this may be a root node (or an error).
}
if ((nodeData.size() == 1) 
    && (children.size() == 0))
{
    // Single data entry node, use simple syntax.
    if (nestedContext)
        status << Ionflux::ObjectBase::escape(getData(0), "{}\n") << "\n";
    else
        /* Rare case of a root node with only one data entry, but 
           still possible. */
       status << "'" << Ionflux::ObjectBase::escape(getData(0), "'{}\n") 
           << "'\n";
    return status.str();
}
// Multi-data entry node or parent node, use nested syntax.
if (nestedContext)
    status << "{\n";
// Add data entries.
for (unsigned int i = 0; i < nodeData.size(); i++)
{
    if (nestedContext)
        status << levelIndent << indent;
    status << "'" << Ionflux::ObjectBase::escape(getData(i), "'{}\n") 
        << "'\n";
}
// Add child nodes.
Node *currentChild;
for (unsigned int i = 0; i < children.size(); i++)
{
    currentChild = children[i];
    status << currentChild->toConfig(indent, level + 1);
}
if (nestedContext)
    status << levelIndent << "}\n";
>>>
    return = {
        value = status.str()
        desc = Configuration file representation of the node
    }
}

# Pure virtual member functions.

# operations

