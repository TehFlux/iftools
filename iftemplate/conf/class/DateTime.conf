# ==========================================================================
# IFTemplate - Ionflux Template Processor
# Copyright © 2012-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# DateTime.conf              Class configuration.
# ==========================================================================
# 
# This file is part of IFTemplate - Ionflux Template Processor.
# 
# IFTemplate - Ionflux Template Processor is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# IFTemplate - Ionflux Template Processor is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '<string>'
	    '<ctime>'
	    '"iftemplate/constants.hpp"'
	    '"iftemplate/types.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<iostream>'
        '<iomanip>'
        '<sstream>'
        '<fstream>'
        '<cstdlib>'
        '"ifobject/utils.hpp"'
        '"iftemplate/IFTemplateError.hpp"'
	    '"iftemplate/TimeZone.hpp"'
    }
}

# forward declarations
forward = {
    'class TimeZone'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = DateTime
	shortDesc = Date and time
	title = Date and time
	longDesc = Date and time type with various manipulation and conversion facilities.
	group.name = iftemplate
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    # Features.
    features = {
        'copy'
        'upcast'
        'create'
        'classinfo'
    }
    create = {
        extendedCreate = true
        allocationError = IFTemplateError("Could not allocate object.")
    }
}

# Member variables.
variable.protected[] = {
    type = bool
    name = dstState
    desc = Broken down time: DST flag
}
variable.protected[] = {
    type = int
    name = utcOffset
    desc = Broken down time: UTC offset (minutes)
}
variable.protected[] = {
    type = std::string
    name = timestamp
    desc = Timestamp (string representation, "YYYY-MM-DD HH:MM:SS")
}
variable.protected[] = {
    type = Ionflux::Template::TimeZoneConstVector
    name = defaultTimeZones
    desc = Default time zones
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::Template::TimeTicks
    name = ticks
    desc = Number of UTC seconds since 0001-01-01 00:00:00
    readOnly = true
}
property.protected[] = {
    type = Ionflux::Template::TimeZone*
    setFromType = Ionflux::Template::TimeZone*
    name = timeZone
    desc = time zone
    managed = true
    impl.set = 	<<<
if (timeZone == newTimeZone)
    return;
if (newTimeZone != 0)
    addLocalRef(newTimeZone);
if (timeZone != 0)
{
    dstState = false;
    utcOffset = 0;
    removeLocalRef(timeZone);
}
timeZone = newTimeZone;
updateBrokenDownTime(0);
>>>
}
property.protected[] = {
    type = Ionflux::Template::Year
    name = year
    desc = Broken down time: year
    readOnly = true
}
property.protected[] = {
    type = int
    name = month
    desc = Broken down time: month
    readOnly = true
}
property.protected[] = {
    type = int
    name = day
    desc = Broken down time: Day of month (1...31)
    readOnly = true
}
property.protected[] = {
    type = int
    name = hour
    desc = Broken down time: Hour (0...23)
    readOnly = true
}
property.protected[] = {
    type = int
    name = minute
    desc = Broken down time: Minute (0...59)
    readOnly = true
}
property.protected[] = {
    type = int
    name = second
    desc = Broken down time: Second (0...59)
    readOnly = true
}
property.protected[] = {
    type = int
    name = weekDay
    desc = Broken down time: Day of week (0...6, where 0 = Sunday)
    readOnly = true
}
property.protected[] = {
    type = int
    name = yearDay
    desc = Broken down time: Day of year (1...366)
    readOnly = true
}

# Public static constants.
constant.public[] = {
    type = std::string
    name = TIMESTAMP_DATE_SEP
    desc = Timestamp date separator
    value = "-"
}
constant.public[] = {
    type = std::string
    name = TIMESTAMP_TIME_SEP
    desc = Timestamp time separator
    value = ":"
}
constant.public[] = {
    type = std::string
    name = TIMESTAMP_DATETIME_SEP
    desc = Timestamp date/time separator
    value = " "
}
constant.public[] = {
    type = int
    name = NUM_DAYS[]
    desc = Number of days up to the beginning of the first day of month j + 1 for non-leap years (NUM_DAYS[0...11]) and leap years (NUM_DAYS[12...23])
    value = <<<
{
	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
	0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 }
>>>
}
constant.public[] = {
    type = int
    name = LEAP_MONTH
    desc = Leap month
    value = 2
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = POSIX_EPOCH
    desc = Start tick count for POSIX epoch
    value = 62135596800LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_400Y
    desc = Leap year neutral tick step: 400 years
    value = 12622780800LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_100Y
    desc = Leap year neutral tick step: 100 years
    value = 3155673600LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_4Y
    desc = Leap year neutral tick step: 4 years
    value = 126230400LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_3Y
    desc = Leap year neutral tick step: 3 years
    value = 94608000LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_1Y
    desc = Leap year neutral tick step: 1 year
    value = 31536000LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = TICKS_1D
    desc = Time ticks per day
    value = 86400LL
}
constant.public[] = {
    type = Ionflux::Template::TimeTicks
    name = REF_SUNDAY
    desc = Reference tick value of a Sunday
    value = 63223891200LL
}
constant.public[] = {
    type = char*
    name = WEEKDAY_NAME[7]
    desc = Weekday names
    value = <<<
{
	"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", 
	"Saturday" }
>>>
}
constant.public[] = {
    type = char*
    name = WEEKDAY_NAME_SHORT[7]
    desc = Weekday names (short)
    value = <<<
{
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }
>>>
}
constant.public[] = {
    type = char*
    name = MONTH_NAME[12]
    desc = Month names
    value = <<<
{
	"January", "February", "March", "April", "May", "June", "July", "August",
	"September", "October", "November", "December" }
>>>
}
constant.public[] = {
    type = char*
    name = MONTH_NAME_SHORT[12]
    desc = Month names (short)
    value = <<<
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", 
	"Nov", "Dec" }
>>>
}

# time zone constants

constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC
    desc = Time zone: UTC
    value = <<<
Ionflux::Template::TimeZone(0, "Coordinated Universal Time", 
    "Coordinated Universal Time", "UTC", "UTC", 
    "UTC:+0000:Rabat:Reykjavik:Ouagadougou:Accra:Lome:Yamoussoukro:Bamako:"
    "Monrovia:Freetown:Conakry:Dakar:Banjul:Bissau:Praia:Laayoune")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0100
    desc = Time zone: UTC+0100
    value = <<<
Ionflux::Template::TimeZone(60, "Coordinated Universal Time +0100", 
	"Coordinated Universal Time +0100", "+0100", "+0100", 
	"UTC+0100:+0100:Algiers:Tunis:Tripoli:Kinshasa:Luanda:Windhoek:Yaounde:"
	"Bangui:Brazzaville:Libreville:Malabo:Abuja:N'Djamena:Sao Tome:Niamey:"
	"Porto-Novo")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0200
    desc = Time zone: UTC+0200
    value = <<<
Ionflux::Template::TimeZone(120, "Coordinated Universal Time +0200", 
	"Coordinated Universal Time +0200", "+0200", "+0200", 
	"UTC+0200:+0200:Amman:Damascus:Beirut:Jerusalem:Pretoria:Lilongwe:Lusaka:"
	"Harare:Kigali:Bujumbura:Gaborone:Maputo:Mbabane:Maseru:Kampala:Khartoum")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0300
    desc = Time zone: UTC+0300
    value = <<<
Ionflux::Template::TimeZone(180, "Coordinated Universal Time +0300", 
	"Coordinated Universal Time +0300", "+0300", "+0300", 
	"UTC+0300:+0300:Baghdad:Riyadh:Sanaa:Kuwait:Manama:Doha:Nairobi:Asmara:"
	"Djibouti:Addis Ababa:Mogadishu:Kampala:Dar es Salaam:Antananarivo:"
	"Moroni")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0330
    desc = Time zone: UTC+0330
    value = <<<
Ionflux::Template::TimeZone(210, "Coordinated Universal Time +0330", 
	"Coordinated Universal Time +0330", "+0330", "+0330", 
	"UTC+0330:+0330:Tehran")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0400
    desc = Time zone: UTC+0400
    value = <<<
Ionflux::Template::TimeZone(240, "Coordinated Universal Time +0400", 
	"Coordinated Universal Time +0400", "+0400", "+0400", 
	"UTC+0400:+0400:Tbilisi:Yerevan:Baku:Abu Dhabi:Muscat:Victoria:"
	"Port Louis:Saint-Denis")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0430
    desc = Time zone: UTC+0430
    value = <<<
Ionflux::Template::TimeZone(270, "Coordinated Universal Time +0430", 
	"Coordinated Universal Time +0430", "+0430", "+0430", 
	"UTC+0430:+0430:Kabul:Kandahar")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0500
    desc = Time zone: UTC+0500
    value = <<<
Ionflux::Template::TimeZone(300, "Coordinated Universal Time +0500", 
	"Coordinated Universal Time +0500", "+0500", "+0500", 
	"UTC+0500:+0500:Male:Islamabad:Bishkek:Dushanbo:Ashgabat:Tashkent")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0530
    desc = Time zone: UTC+0530
    value = <<<
Ionflux::Template::TimeZone(330, "Coordinated Universal Time +0530", 
	"Coordinated Universal Time +0530", "+0530", "+0530", 
	"UTC+0530:+0530:New Delhi:Mumbai:Bombay:Kolkata:Calcutta")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0545
    desc = Time zone: UTC+0545
    value = <<<
Ionflux::Template::TimeZone(345, "Coordinated Universal Time +0545", 
	"Coordinated Universal Time +0545", "+0545", "+0545", 
	"UTC+0545:+0545:Kathmandu")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0600
    desc = Time zone: UTC+0600
    value = <<<
Ionflux::Template::TimeZone(360, "Coordinated Universal Time +0600", 
	"Coordinated Universal Time +0600", "+0600", "+0600", 
	"UTC+0600:+0600:Colombo:Dhaka:Thimphu:Astana:Omsk:Novosibirsk")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0630
    desc = Time zone: UTC+0630
    value = <<<
Ionflux::Template::TimeZone(390, "Coordinated Universal Time +0630", 
	"Coordinated Universal Time +0630", "+0630", "+0630", 
	"UTC+0630:+0630:Rangoon")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0700
    desc = Time zone: UTC+0700
    value = <<<
Ionflux::Template::TimeZone(420, "Coordinated Universal Time +0700", 
	"Coordinated Universal Time +0700", "+0700", "+0700", 
	"UTC+0700:+0700:Jakarta:Singapore:Hanoi:Bangkok:Phnom Penh:Vientiane")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0800
    desc = Time zone: UTC+0800
    value = <<<
Ionflux::Template::TimeZone(480, "Coordinated Universal Time +0800", 
	"Coordinated Universal Time +0800", "+0800", "+0800", 
	"UTC+0800:+0800:Beijing:Hong Kong:Macau:Shanghai:Taipei:Perth:Dili:"
	"Bandar Seri Begawan:Manila:Ulaanbaatar")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0900
    desc = Time zone: UTC+0900
    value = <<<
Ionflux::Template::TimeZone(540, "Coordinated Universal Time +0900", 
	"Coordinated Universal Time +0900", "+0900", "+0900", 
	"UTC+0900:+0900:Tokyo:Pyongyang:Seoul:Koror")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P0930
    desc = Time zone: UTC+0930
    value = <<<
Ionflux::Template::TimeZone(570, "Coordinated Universal Time +0930", 
	"Coordinated Universal Time +0930", "+0930", "+0930", 
	"UTC+0930:+0930:Alice Springs")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P1000
    desc = Time zone: UTC+1000
    value = <<<
Ionflux::Template::TimeZone(600, "Coordinated Universal Time +1000", 
	"Coordinated Universal Time +1000", "+1000", "+1000", 
	"UTC+1000:+1000:Hobart:Melbourne:Canberra:Sydney:Brisbane:Caims:"
	"Port Moresby:Vladivostok:Saipan:Hagatna")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P1100
    desc = Time zone: UTC+1100
    value = <<<
Ionflux::Template::TimeZone(660, "Coordinated Universal Time +1100", 
	"Coordinated Universal Time +1100", "+1100", "+1100", 
	"UTC+1100:+1100:Honiara:Port-Vila:Noumea:Palikir")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_P1200
    desc = Time zone: UTC+1200
    value = <<<
Ionflux::Template::TimeZone(720, "Coordinated Universal Time +1200", 
	"Coordinated Universal Time +1200", "+1200", "+1200", 
	"UTC+1200:+1200:Wellington:Auckland:Christchurch:Suva:Funafuti:"
	"Yaren District:Tarawa:Majuro")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0100
    desc = Time zone: UTC-0100
    value = <<<
Ionflux::Template::TimeZone(-60, "Coordinated Universal Time -0100", 
	"Coordinated Universal Time -0100", "-0100", "-0100", 
	"UTC-0100:-0100:Praia")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0200
    desc = Time zone: UTC-0200
    value = <<<
Ionflux::Template::TimeZone(-120, "Coordinated Universal Time -0200", 
	"Coordinated Universal Time -0200", "-0200", "-0200", 
	"UTC-0200:-0200")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0300
    desc = Time zone: UTC-0300
    value = <<<
Ionflux::Template::TimeZone(-180, "Coordinated Universal Time -0300", 
	"Coordinated Universal Time -0300", "-0300", "-0300", 
	"UTC-0300:-0300:Brasilia:Montevideo:Buenos Aires:Paramaribo:French Guiana:"
	"Nuuk")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0400
    desc = Time zone: UTC-0400
    value = <<<
Ionflux::Template::TimeZone(-240, "Coordinated Universal Time -0400", 
	"Coordinated Universal Time -0400", "-0400", "-0400", 
	"UTC-0400:-0400:Asuncion:La Paz:Caracas:Port-of-Spain:Georgetown:Santiago:"
	"Santo Domingo:Puerto Rico:Montserrat:Guadeloupe:Martinique:Barbados:"
	"Grenada:Dominica:St. Lucia:Halifax:Stanley")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0500
    desc = Time zone: UTC-0500
    value = <<<
Ionflux::Template::TimeZone(-300, "Coordinated Universal Time -0500", 
	"Coordinated Universal Time -0500", "-0500", "-0500", 
	"UTC-0500:-0500:Bogota:Quito:Lima:Panama:Nassau:Havana:Kingston:"
	"Port-au-Prince")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0600
    desc = Time zone: UTC-0600
    value = <<<
Ionflux::Template::TimeZone(-360, "Coordinated Universal Time -0600", 
	"Coordinated Universal Time -0600", "-0600", "-0600", 
	"UTC-0600:-0600:San Jose:Managua:Tegucigalpa:San Salvador:Guatemala:"
	"Belmopan")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0700
    desc = Time zone: UTC-0700
    value = <<<
Ionflux::Template::TimeZone(-420, "Coordinated Universal Time -0700", 
	"Coordinated Universal Time -0700", "-0700", "-0700", 
	"UTC-0700:-0700")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0800
    desc = Time zone: UTC-0800
    value = <<<
Ionflux::Template::TimeZone(-480, "Coordinated Universal Time -0800", 
	"Coordinated Universal Time -0800", "-0800", "-0800", 
	"UTC-0800:-0800")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M0900
    desc = Time zone: UTC-0900
    value = <<<
Ionflux::Template::TimeZone(-540, "Coordinated Universal Time -0900", 
	"Coordinated Universal Time -0900", "-0900", "-0900", 
	"UTC-0900:-0900:Adamstown")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M1000
    desc = Time zone: UTC-1000
    value = <<<
Ionflux::Template::TimeZone(-600, "Coordinated Universal Time -1000", 
	"Coordinated Universal Time -1000", "-1000", "-1000", 
	"UTC-1000:-1000:Honolulu:Papeete")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M1100
    desc = Time zone: UTC-1100
    value = <<<
Ionflux::Template::TimeZone(-660, "Coordinated Universal Time -1100", 
	"Coordinated Universal Time -1100", "-1100", "-1100", 
	"UTC-1100:-1100:Nuku'alofa:Apia:Pago Pago")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UTC_M1200
    desc = Time zone: UTC-1200
    value = <<<
Ionflux::Template::TimeZone(-720, "Coordinated Universal Time -1200", 
	"Coordinated Universal Time -1200", "-1200", "-1200", 
	"UTC-1200:-1200")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_GMT
    desc = Time zone: GMT
    value = <<<
Ionflux::Template::TimeZone(0, "Greenwich Mean Time",
	"Greenwich Mean Time", "GMT", "GMT", "GMT")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_EUROPE_WESTERN
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(0, 
	TimeZone::DSR_TO_DST_EUROPE_WESTERN, 
	TimeZone::DSR_TO_NORMAL_EUROPE_WESTERN,
	"Western European Time",
	"Western European Summer Time",
	"WET", "WEST", 
	"WET:Europe/Western:Western Europe:Dublin:Lisbon")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_EUROPE_CENTRAL
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(60, 
	TimeZone::DSR_TO_DST_EUROPE_CENTRAL, 
	TimeZone::DSR_TO_NORMAL_EUROPE_CENTRAL,
	"Central European Time",
	"Central European Summer Time",
	"CET", "CEST", 
	"CET:Europe/Central:Central Europe:Amsterdam:Belgrade:Berlin:Bern:"
	"Bratislava:Brussels:Budapest:Copenhagen:Ljubljana:Luxembourg:"
	"Madrid:Oslo:Paris:Prague:Rome:Sarajevo:Stockholm:Tirana:Valletta:"
	"Vienna:Warsaw:Zagreb")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_EUROPE_EASTERN
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(120, 
	TimeZone::DSR_TO_DST_EUROPE_EASTERN, 
	TimeZone::DSR_TO_NORMAL_EUROPE_EASTERN,
	"Eastern European Time",
	"Eastern European Summer Time",
	"EET", "EEST", 
	"EET:Europe/Eastern:Eastern Europe:Ankara:Athens:Bucharest:Helsinki:"
	"Kiev:Minsk:Nicosia:Riga:Sofia:Tallinn:Vilnius")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_UK
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(0, 
	TimeZone::DSR_TO_DST_EUROPE_WESTERN, 
	TimeZone::DSR_TO_NORMAL_EUROPE_WESTERN,
	"Western European Time",
	"British Summer Time",
	"WET", "BST", 
	"United Kingdom:London")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_USA_EASTERN
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(-300, 
	TimeZone::DSR_TO_DST_USA,
	TimeZone::DSR_TO_NORMAL_USA,
	"Eastern Standard Time",
	"Eastern Daylight Time",
	"EST", "EDT", 
	"EST:USA/Eastern:Eastern USA:Canada/Eastern:Eastern Canada:New York:"
	"Washington, D.C.:Washington DC:Detroit:Cleveland:Columbus:Philadelphia:"
	"Boston:Baltimore:Atlanta:Jacksonville:Toronto:Ottawa:Montreal:Quebec")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_USA_CENTRAL
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(-360, 
	TimeZone::DSR_TO_DST_USA, 
	TimeZone::DSR_TO_NORMAL_USA,
	"Central Standard Time",
	"Central Daylight Time",
	"CST", "CDT", 
	"CST:USA/Central:Central USA:Canada/Central:Central Canada:Chicago:"
	"Dallas:San Antonio:Houston:New Orleans:St. Louis:Milwaukee:Minneapolis:"
	"Winnipeg:Mexico City")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_USA_MOUNTAIN
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(-420, 
	TimeZone::DSR_TO_DST_USA, 
	TimeZone::DSR_TO_NORMAL_USA,
	"Mountain Standard Time",
	"Mountain Daylight Time",
	"MST", "MDT", 
	"MST:USA/Mountain:Mountain USA:Canada/Mountain:Mountain Canada:"
	"Denver:Salt Lake City:Phoenix:El Paso:Edmonton:Calgary")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_USA_PACIFIC
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(-480, 
	TimeZone::DSR_TO_DST_USA, 
	TimeZone::DSR_TO_NORMAL_USA,
	"Pacific Standard Time",
	"Pacific Daylight Time",
	"PST", "PDT", 
	"PST:USA/Pacific:Pacific USA:Canada/Pacific:Pacific Canada:Los Angeles:"
	"Las Vegas:San Francisco:San Diego:Portland:Seattle:Vancouver")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_USA_ALASKA
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(-540, 
	TimeZone::DSR_TO_DST_USA, 
	TimeZone::DSR_TO_NORMAL_USA,
	"Alaska Standard Time",
	"Alaska Daylight Time",
	"AKST", "AKDT", 
	"AKST:USA/Alaska:Alaska USA:Anchorage")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_RUSSIA_WESTERN
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(180, 
	TimeZone::DSR_TO_DST_EUROPE_CENTRAL, 
	TimeZone::DSR_TO_NORMAL_EUROPE_CENTRAL,
	"UTC+03",
	"UTC+04",
	"UTC+03", "UTC+04", 
	"Russia/Western:Western Russia:Moscow")
>>>
}
constant.public[] = {
    type = Ionflux::Template::TimeZone
    name = TZ_EGYPT
    desc = Time zone: 
    value = <<<
Ionflux::Template::TimeZone(120, 
	TimeZone::DSR_TO_DST_EGYPT, 
	TimeZone::DSR_TO_NORMAL_EGYPT,
	"UTC+02",
	"UTC+03",
	"UTC+02", "UTC+03", 
	"Cairo")
>>>
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = dstState
        value = false
    }
    initializer[] = {
        name = utcOffset
        value = 0
    }
    initializer[] = {
        name = timestamp
        value = ""
    }
    initializer[] = {
        name = ticks
        value = 0
    }
    initializer[] = {
        name = timeZone
        value = 0
    }
    initializer[] = {
        name = year
        value = 1
    }
    initializer[] = {
        name = month
        value = 1
    }
    initializer[] = {
        name = day
        value = 1
    }
    initializer[] = {
        name = hour
        value = 0
    }
    initializer[] = {
        name = minute
        value = 0
    }
    initializer[] = {
        name = second
        value = 0
    }
    initializer[] = {
        name = weekDay
        value = 0
    }
    initializer[] = {
        name = yearDay
        value = 0
    }
    impl = <<<
initTimeZones();
setTimePosix(time(0));
>>>
}
constructor.public[] = {
    initializer[] = {
        name = dstState
        value = false
    }
    initializer[] = {
        name = utcOffset
        value = 0
    }
    initializer[] = {
        name = timestamp
        value = ""
    }
    initializer[] = {
        name = ticks
        value = 0
    }
    initializer[] = {
        name = timeZone
        value = 0
    }
    initializer[] = {
        name = year
        value = 1
    }
    initializer[] = {
        name = month
        value = 1
    }
    initializer[] = {
        name = day
        value = 1
    }
    initializer[] = {
        name = hour
        value = 0
    }
    initializer[] = {
        name = minute
        value = 0
    }
    initializer[] = {
        name = second
        value = 0
    }
    initializer[] = {
        name = weekDay
        value = 0
    }
    initializer[] = {
        name = yearDay
        value = 0
    }
    param[] = {
        type = Ionflux::Template::TimeTicks
        name = initTime
        desc = Time tick value
    }
    impl = <<<
initTimeZones();
setTimeTicks(initTime);
>>>
}
constructor.public[] = {
    initializer[] = {
        name = dstState
        value = false
    }
    initializer[] = {
        name = utcOffset
        value = 0
    }
    initializer[] = {
        name = timestamp
        value = ""
    }
    initializer[] = {
        name = ticks
        value = 0
    }
    initializer[] = {
        name = timeZone
        value = 0
    }
    initializer[] = {
        name = year
        value = 1
    }
    initializer[] = {
        name = month
        value = 1
    }
    initializer[] = {
        name = day
        value = 1
    }
    initializer[] = {
        name = hour
        value = 0
    }
    initializer[] = {
        name = minute
        value = 0
    }
    initializer[] = {
        name = second
        value = 0
    }
    initializer[] = {
        name = weekDay
        value = 0
    }
    initializer[] = {
        name = yearDay
        value = 0
    }
    param[] = {
        type = struct tm
        name = initTime
        desc = Broken down calendar time
    }
    impl = <<<
initTimeZones();
setTime(initTime);
>>>
}
constructor.public[] = {
    initializer[] = {
        name = dstState
        value = false
    }
    initializer[] = {
        name = utcOffset
        value = 0
    }
    initializer[] = {
        name = timestamp
        value = ""
    }
    initializer[] = {
        name = ticks
        value = 0
    }
    initializer[] = {
        name = timeZone
        value = 0
    }
    initializer[] = {
        name = year
        value = 1
    }
    initializer[] = {
        name = month
        value = 1
    }
    initializer[] = {
        name = day
        value = 1
    }
    initializer[] = {
        name = hour
        value = 0
    }
    initializer[] = {
        name = minute
        value = 0
    }
    initializer[] = {
        name = second
        value = 0
    }
    initializer[] = {
        name = weekDay
        value = 0
    }
    initializer[] = {
        name = yearDay
        value = 0
    }
    param[] = {
        type = const std::string&
        name = initTime
        desc = Timestamp
    }
    impl = <<<
initTimeZones();
setTime(initTime);
>>>
}
constructor.public[] = {
    initializer[] = {
        name = dstState
        value = false
    }
    initializer[] = {
        name = utcOffset
        value = 0
    }
    initializer[] = {
        name = timestamp
        value = ""
    }
    initializer[] = {
        name = ticks
        value = 0
    }
    initializer[] = {
        name = timeZone
        value = 0
    }
    initializer[] = {
        name = year
        value = 1
    }
    initializer[] = {
        name = month
        value = 1
    }
    initializer[] = {
        name = day
        value = 1
    }
    initializer[] = {
        name = hour
        value = 0
    }
    initializer[] = {
        name = minute
        value = 0
    }
    initializer[] = {
        name = second
        value = 0
    }
    initializer[] = {
        name = weekDay
        value = 0
    }
    initializer[] = {
        name = yearDay
        value = 0
    }
    param[] = {
        type = Ionflux::Template::Year
        name = initYear
        desc = year
    }
    param[] = {
        type = int
        name = initMonth
        desc = month (1...12)
    }
    param[] = {
        type = int
        name = initDay
        desc = day of month (1...31)
    }
    param[] = {
        type = int
        name = initHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = initMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = initSecond
        desc = second (0...59)
    }
    impl = <<<
initTimeZones();
setTime(initYear, initMonth, initDay, initHour, initMinute, initSecond);
>>>
}
constructor.copy.impl = initTimeZones();\
setTime(other);

# Destructor.
destructor.impl = 

# Protected member functions.
function.protected[] = {
    spec = virtual
    type = void
    name = parseTimestamp
	shortDesc = Parse a timestamp
	longDesc = <<<
Parse a timestamp in string representation ("YYYY-MM-DD HH:MM:SS").
>>>
	param[] = {
	    type = const std::string&
	    name = source
	    desc = timestamp
	}
	impl = <<<
if (source.size() == 0)
    return;
Ionflux::ObjectBase::StringVector parts;
Ionflux::ObjectBase::StringVector dateParts;
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(source, " ", parts);
// Extract date.
if (parts.size() < 1)
    return;
Ionflux::ObjectBase::explode(parts[0], "-", dateParts);
if (dateParts.size() < 3)
    return;
year = ::strtol(dateParts[0].c_str(), 0, 10);
month = ::strtol(dateParts[1].c_str(), 0, 10);
day = ::strtol(dateParts[2].c_str(), 0, 10);
hour = 0;
minute = 0;
second = 0;
timestamp = source;
// Extract time.
if (parts.size() < 2)
    return;
Ionflux::ObjectBase::explode(parts[1], ":", timeParts);
if (timeParts.size() < 1)
    return;
hour = ::strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() < 2)
    return;
minute = ::strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() < 3)
    return;
second = ::strtol(timeParts[2].c_str(), 0, 10);
>>>
}
function.protected[] = {
    spec = virtual
    type = std::string
    name = createTimestamp
	shortDesc = Create a timestamp
	longDesc = <<<
Create a timestamp in string representation ("YYYY-MM-DD HH:MM:SS").

\sa getTimestamp()
>>>
	impl = <<<
std::ostringstream result;
result << right << setfill('0') << std::setw(4)
    << year << TIMESTAMP_DATE_SEP << std::setw(2) 
    << month << TIMESTAMP_DATE_SEP << std::setw(2) 
    << day << TIMESTAMP_DATETIME_SEP << std::setw(2) 
    << hour << TIMESTAMP_TIME_SEP << std::setw(2) 
    << minute << TIMESTAMP_TIME_SEP << std::setw(2) 
    << second;
>>>
	return = {
	    value = result.str()
	    desc = Timestamp
	}
}
function.protected[] = {
    spec = virtual
    type = void
    name = updateTicks
	shortDesc = Update ticks from broken down calendar time
	longDesc = <<<
Update ticks from broken down calendar time.
>>>
	impl = <<<
ticks = 0;
ticks += (((((year - 1) * 365 + countLeapYears(year) 
    + NUM_DAYS[month - 1] + day - 1) * 24 + hour) * 60 + minute) 
    * 60 + second);
if (isLeapYear(year) && (month > LEAP_MONTH))
    ticks += TICKS_1D;
timestamp = "";
// Normalize the broken down time, set day of week etc.
updateBrokenDownTime(0);
>>>
}
function.protected[] = {
    spec = virtual
    type = void
    name = updateBrokenDownTime
	shortDesc = Update broken down calendar time from ticks
	longDesc = <<<
Updates the broken down calendar time from the UTC ticks. An additional offset may be specified to calculate local time.
>>>
	param[] = {
	    type = int
	    name = tickOffset
	    desc = tick offset
	}
	impl = <<<
TimeTicks ticksLeft = ticks + tickOffset;
TimeTicks num400Y = 0;
TimeTicks num100Y = 0;
TimeTicks num4Y = 0;
TimeTicks num3Y = 0;
TimeTicks num1Y = 0;
int leapOffset = 0;
/* Determine the coefficients of 400, 100, 4, 3 and 1 year intervals that 
   make up the resulting year. These intervals represent the leap year 
   cycles and thus each have constant amounts of ticks. */
num400Y = ticksLeft / TICKS_400Y;
ticksLeft = ticksLeft % TICKS_400Y;
num100Y = ticksLeft / TICKS_100Y;
ticksLeft = ticksLeft % TICKS_100Y;
num4Y = ticksLeft / TICKS_4Y;
ticksLeft = ticksLeft % TICKS_4Y;
num3Y = ticksLeft / TICKS_3Y;
ticksLeft = ticksLeft % TICKS_3Y;
num1Y = ticksLeft / TICKS_1Y;
ticksLeft = ticksLeft % TICKS_1Y;
year = num400Y * 400 + num100Y * 100 + num4Y * 4 + num3Y * 3 + num1Y + 1;
/* We have a leap year if this year is the fourth year after a complete 4 
   year cycle block. That means a three year interval has been matched. 
   Otherwise, a three year interval will not match. */
leapOffset = num3Y;
int checkTicks = 0;
bool found = false;
int i = 11;
/* Determine the month by checking which interval of days fits within the 
   remaining ticks. */
while ((i >= 0) && !found)
{
    checkTicks = NUM_DAYS[leapOffset * 12 + i] * TICKS_1D;
    if ((ticksLeft - checkTicks) >= 0)
    {
        month = i + 1;
        ticksLeft -= checkTicks;
        found = true;
    }
    i--;
}
// Determine the day of month and day of year.
day = ticksLeft / TICKS_1D + 1;
ticksLeft = ticksLeft % TICKS_1D;
yearDay = NUM_DAYS[leapOffset * 12 + month - 1] + day;
// Determine the time of day.
hour = ticksLeft / 3600;
ticksLeft = ticksLeft % 3600;
minute = ticksLeft / 60;
second = ticksLeft % 60;
// Determine the day of week.
TimeTicks dayOffset = (ticks + tickOffset - REF_SUNDAY) / TICKS_1D;
ticksLeft = (ticks + tickOffset - REF_SUNDAY) % TICKS_1D;
if (ticksLeft < 0)
    dayOffset--;
weekDay = dayOffset % 7;
if (weekDay < 0)
    weekDay += 7;
// Another pass might be needed to calculate local time.
if ((timeZone != 0) && (tickOffset == 0))
{
    /* This call requires the broken down time to be plain UTC.
       We ensure this is the case by having checked tickOffset. */
    utcOffset = timeZone->getCurrentOffset(*this);
    if (utcOffset > timeZone->getOffset())
        dstState = true;
    /* Recalculate only if this actually is another time zone.
       (Otherwise this would cause an infinite loop.) */
    if (utcOffset != 0)
        updateBrokenDownTime(utcOffset * 60);
}
timestamp = "";
>>>
}
function.protected[] = {
    spec = virtual
    type = void
    name = initTimeZones
	shortDesc = Initialize default time zones
	longDesc = <<<
Initialize default time zones.
>>>
	impl = <<<
// Add time zones here to make them selectable by alias name.
defaultTimeZones.push_back(&TZ_UTC);
defaultTimeZones.push_back(&TZ_GMT);
defaultTimeZones.push_back(&TZ_EUROPE_WESTERN);
defaultTimeZones.push_back(&TZ_EUROPE_CENTRAL);
defaultTimeZones.push_back(&TZ_EUROPE_EASTERN);
defaultTimeZones.push_back(&TZ_UK);
defaultTimeZones.push_back(&TZ_USA_EASTERN);
defaultTimeZones.push_back(&TZ_USA_CENTRAL);
defaultTimeZones.push_back(&TZ_USA_MOUNTAIN);
defaultTimeZones.push_back(&TZ_USA_PACIFIC);
defaultTimeZones.push_back(&TZ_USA_ALASKA);
defaultTimeZones.push_back(&TZ_RUSSIA_WESTERN);
defaultTimeZones.push_back(&TZ_EGYPT);
defaultTimeZones.push_back(&TZ_UTC_P0100);
defaultTimeZones.push_back(&TZ_UTC_P0200);
defaultTimeZones.push_back(&TZ_UTC_P0300);
defaultTimeZones.push_back(&TZ_UTC_P0330);
defaultTimeZones.push_back(&TZ_UTC_P0400);
defaultTimeZones.push_back(&TZ_UTC_P0430);
defaultTimeZones.push_back(&TZ_UTC_P0500);
defaultTimeZones.push_back(&TZ_UTC_P0530);
defaultTimeZones.push_back(&TZ_UTC_P0545);
defaultTimeZones.push_back(&TZ_UTC_P0600);
defaultTimeZones.push_back(&TZ_UTC_P0630);
defaultTimeZones.push_back(&TZ_UTC_P0700);
defaultTimeZones.push_back(&TZ_UTC_P0800);
defaultTimeZones.push_back(&TZ_UTC_P0900);
defaultTimeZones.push_back(&TZ_UTC_P0930);
defaultTimeZones.push_back(&TZ_UTC_P1000);
defaultTimeZones.push_back(&TZ_UTC_P1100);
defaultTimeZones.push_back(&TZ_UTC_P1200);
defaultTimeZones.push_back(&TZ_UTC_M0100);
defaultTimeZones.push_back(&TZ_UTC_M0200);
defaultTimeZones.push_back(&TZ_UTC_M0300);
defaultTimeZones.push_back(&TZ_UTC_M0400);
defaultTimeZones.push_back(&TZ_UTC_M0500);
defaultTimeZones.push_back(&TZ_UTC_M0600);
defaultTimeZones.push_back(&TZ_UTC_M0700);
defaultTimeZones.push_back(&TZ_UTC_M0800);
defaultTimeZones.push_back(&TZ_UTC_M0900);
defaultTimeZones.push_back(&TZ_UTC_M1000);
defaultTimeZones.push_back(&TZ_UTC_M1100);
defaultTimeZones.push_back(&TZ_UTC_M1200);
>>>
}

# Public member functions.
function.copy.impl = setTime(other);
function.public[] = {
    spec = virtual
    type = void
    name = setTimePosix
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
	param[] = {
	    type = time_t
	    name = newTime
	    desc = POSIX time
	}
	impl = <<<
ticks = POSIX_EPOCH + newTime;
updateBrokenDownTime(0);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setTimeTicks
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
	param[] = {
	    type = Ionflux::Template::TimeTicks
	    name = newTime
	    desc = Time ticks
	}
	impl = <<<
ticks = newTime;
updateBrokenDownTime(0);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setTime
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
	param[] = {
	    type = struct tm
	    name = newTime
	    desc = Broken down calendar time
	}
	impl = <<<
year = newTime.tm_year + 1900;
month = newTime.tm_mon + 1;
day = newTime.tm_mday;
hour = newTime.tm_hour;
minute = newTime.tm_min;
second = newTime.tm_sec;
updateTicks();
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setTime
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp
	}
	impl = <<<
parseTimestamp(newTime);
updateTicks();
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setTime
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = newTime
	    desc = Datetime object
	}
	impl = setTimeTicks(newTime.getTicks());
}
function.public[] = {
    spec = virtual
    type = void
    name = setTime
	shortDesc = Set time
	longDesc = <<<
Set the date and time (UTC) represented by this DateTime object.

\sa setLocalTime()
>>>
    param[] = {
        type = Ionflux::Template::Year
        name = newYear
        desc = year
    }
    param[] = {
        type = int
        name = newMonth
        desc = month (1...12)
    }
    param[] = {
        type = int
        name = newDay
        desc = day of month (1...31)
    }
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	impl = <<<
year = newYear;
month = newMonth;
day = newDay;
hour = newHour;
minute = newMinute;
second = newSecond;
updateTicks();
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note The source datetime will be treated as local time, regardless of its time zone setting. If you want to set local time from another equivalent local time (i.e. both times represent the same UTC time), you should use standard assignment or setTime() instead of this function.

\sa setTimeZone() setTime()
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = newTime
	    desc = Datetime object
	}
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
setLocalTime(newTime.getYear(), newTime.getMonth(), newTime.getDay(),
    newTime.getHour(), newTime.getMinute(), newTime.getSecond(), 
    newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note The source datetime will be treated as local time, regardless of its time zone setting. If you want to set local time from another equivalent local time (i.e. both times represent the same UTC time), you should use standard assignment or setTime() instead of this function.

\sa setTimeZone() setTime()
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp
	}
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
parseTimestamp(newTime);
if (timeZone != 0)
{
    // Transform to UTC.
    utcOffset = timeZone->getOffset();
    dstState = newDSTState;
    if (dstState)
        utcOffset += 60;
    minute -= utcOffset;
}
updateTicks();
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note The source datetime will be treated as local time, regardless of its time zone setting. If you want to set local time from another equivalent local time (i.e. both times represent the same UTC time), you should use standard assignment or setTime() instead of this function.

\sa setTimeZone() setTime()
>>>
    param[] = {
        type = Ionflux::Template::Year
        name = newYear
        desc = year
    }
    param[] = {
        type = int
        name = newMonth
        desc = month (1...12)
    }
    param[] = {
        type = int
        name = newDay
        desc = day of month (1...31)
    }
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
if (timeZone != 0)
{
    // Transform to UTC.
    utcOffset = timeZone->getOffset();
    dstState = newDSTState;
    if (dstState)
        utcOffset += 60;
    newMinute -= utcOffset;
}
setTime(newYear, newMonth, newDay, newHour, newMinute, newSecond);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled). The source datetime will be treated as local time, regardless of its time zone setting. If you want to set local time from another equivalent local time (i.e. both times represent the same UTC time), you should use standard assignment or setTime() instead of this function.

\sa setTimeZone() setTime() TimeZone::localIsDST()
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = newTime
	    desc = Datetime object
	}
	impl = <<<
bool newDSTState = false;
if (timeZone != 0)
    newDSTState = timeZone->localIsDST(newTime);
setLocalTime(newTime, newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled).

\sa setTimeZone() setTime() TimeZone::localIsDST()
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp
	}
	impl = <<<
bool newDSTState = false;
DateTime newDT(newTime);
if (timeZone != 0)
    newDSTState = timeZone->localIsDST(newTime);
setLocalTime(newTime, newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalTime
	shortDesc = Set local time
	longDesc = <<<
Set the local date and time represented by this DateTime object.

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled).

\sa setTimeZone() setTime() TimeZone::localIsDST()
>>>
    param[] = {
        type = Ionflux::Template::Year
        name = newYear
        desc = year
    }
    param[] = {
        type = int
        name = newMonth
        desc = month (1...12)
    }
    param[] = {
        type = int
        name = newDay
        desc = day of month (1...31)
    }
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	impl = <<<
bool newDSTState = false;
DateTime newDT(newYear, newMonth, newDay, newHour, newMinute, newSecond);
if (timeZone != 0)
    newDSTState = timeZone->localIsDST(newDT);
setLocalTime(newDT, newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (UTC).
>>>
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	impl = setTime(getYear(), getMonth(), getDay(), newHour, newMinute, newSecond);
}
function.public[] = {
    spec = virtual
    type = void
    name = setHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (UTC).
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp ("HH[:MM[:SS]]")
	}
	impl = <<<
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(newTime, ":", timeParts);
int newHour = 0;
int newMinute = 0;
int newSecond = 0;
if (timeParts.size() == 0)
    return;
if (timeParts.size() >= 1)
    newHour = ::strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() >= 2)
    newMinute = ::strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() >= 3)
    newSecond = ::strtol(timeParts[2].c_str(), 0, 10);
setHMS(newHour, newMinute, newSecond);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (UTC).
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = sourceTime
	    desc = Datetime object
	}
	impl = <<<
setHMS(sourceTime.getHour(), sourceTime.getMinute(), 
		sourceTime.getSecond());
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).
>>>
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
setLocalTime(getYear(), getMonth(), getDay(), newHour, newMinute, 
    newSecond, newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp ("HH[:MM[:SS]]")
	}
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(newTime, ":", timeParts);
int newHour = 0;
int newMinute = 0;
int newSecond = 0;
if (timeParts.size() == 0)
    return;
if (timeParts.size() >= 1)
    newHour = strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() >= 2)
    newMinute = strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() >= 3)
    newSecond = strtol(timeParts[2].c_str(), 0, 10);
setLocalHMS(newHour, newMinute, newSecond, newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = sourceTime
	    desc = Datetime object
	}
	param[] = {
	    type = bool
	    name = newDSTState
	    desc = Whether this local time represents daylight saving time
	}
	impl = <<<
setLocalHMS(sourceTime.getHour(), sourceTime.getMinute(), 
    sourceTime.getSecond(), newDSTState);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled).
>>>
    param[] = {
        type = int
        name = newHour
        desc = hour (0...23)
    }
    param[] = {
        type = int
        name = newMinute
        desc = minute (0...59)
    }
    param[] = {
        type = int
        name = newSecond
        desc = second (0...59)
    }
	impl = <<<
setLocalTime(getYear(), getMonth(), getDay(), newHour, newMinute, 
    newSecond);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled).
>>>
	param[] = {
	    type = const std::string&
	    name = newTime
	    desc = Timestamp ("HH[:MM[:SS]]")
	}
	impl = <<<
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(newTime, ":", timeParts);
int newHour = 0;
int newMinute = 0;
int newSecond = 0;
if (timeParts.size() == 0)
    return;
if (timeParts.size() >= 1)
    newHour = strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() >= 2)
    newMinute = strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() >= 3)
    newSecond = strtol(timeParts[2].c_str(), 0, 10);
setLocalHMS(newHour, newMinute, newSecond);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = setLocalHMS
	shortDesc = Set time of day
	longDesc = <<<
Set the time of day (local time).

\note This function will attempt to determine the DST state automatically. Note that DST state is ambiguous during one hour of the year (see TimeZone::localIsDST() for details on how this case is handled).
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = sourceTime
	    desc = Datetime object
	}
	impl = <<<
setLocalHMS(sourceTime.getHour(), sourceTime.getMinute(), 
    sourceTime.getSecond());
>>>
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::DateTime&
    name = shift
	shortDesc = Shift Datetime
	longDesc = <<<
Shift a DateTime by a specified amount of seconds. (This may be used for TimeZone transformations or DateTime arithmetic.)
>>>
	param[] = {
	    type = Ionflux::Template::TimeTicks
	    name = shiftSeconds
	    desc = Amount of seconds to shift this DateTime
	}
	impl = setTimeTicks(ticks + shiftSeconds);
	return = {
	    value = *this
	    desc = Datetime shifted by specified amount of seconds
	}
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::TimeTicks
    name = diff
	shortDesc = Calculate DateTime difference
	longDesc = <<<
Calculate the difference (in seconds) of two DateTime objects.
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = diffTime
	    desc = DateTime to substract
	}
	impl = 
	return = {
	    value = getTicks() - diffTime.getTicks()
	    desc = Difference of the datetimes, in seconds
	}
}
function.public[] = {
    spec = virtual
    type = void
    name = setTimeZone
	shortDesc = Set time zone
	longDesc = <<<
Sets the time zone of the local time by alias name. If no time zone of the specified alias name is found, UTC is assumed.
>>>
	param[] = {
	    type = const std::string&
	    name = newTimeZone
	    desc = Time zone alias name
	}
	impl = <<<
bool found = false;
unsigned int i = 0;
const TimeZone *currentTimeZone = 0;
while (!found && (i < defaultTimeZones.size()))
{
    currentTimeZone = defaultTimeZones[i];
    if ((currentTimeZone != 0) 
        && currentTimeZone->hasAlias(newTimeZone))
        found = true;
    else
        i++;
}
if (found)
    setTimeZone(currentTimeZone->copy());
>>>
}
function.public[] = {
    spec = virtual
    type = int
    name = compareHMS
	shortDesc = Compare time of day
	longDesc = <<<
Compare time of day (HH:MM:SS) only, without respect to time zone or DST offsets.
>>>
	param[] = {
	    type = int
	    name = otherHour
	    desc = Hour (0...23)
	}
	param[] = {
	    type = int
	    name = otherMinute
	    desc = Minute (0...59)
	}
	param[] = {
	    type = int
	    name = otherSecond
	    desc = Second (0...59)
	}
	impl = <<<
int thisSecs;
int otherSecs;
int result = 0;
thisSecs = (getHour() * 60 + getMinute()) * 60 + getSecond();
otherSecs = (otherHour * 60 + otherMinute) * 60 + otherSecond;
if (thisSecs < otherSecs)
    result = -1;
else
if (thisSecs > otherSecs)
    result = 1;
>>>
	return = {
	    value = result
	    desc = 0 if the times of day are equal, -1 if the time of day of this object is less than, +1 if it is greater than the time of day of the argument
	}
}
function.public[] = {
    spec = virtual
    type = int
    name = compareHMS
	shortDesc = Compare time of day
	longDesc = <<<
Compare time of day (HH:MM:SS) only, without respect to time zone or DST offsets.
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = otherTime
	    desc = DateTime to compare this object with
	}
	impl = 
	return = {
	    value = compareHMS(otherTime.getHour(), otherTime.getMinute(), otherTime.getSecond())
	    desc = 0 if the times of day are equal, -1 if the time of day of this object is less than, +1 if it is greater than the time of day of the argument
	}
}
function.public[] = {
    spec = virtual
    type = int
    name = compareHMS
	shortDesc = Compare time of day
	longDesc = <<<
Compare time of day (HH:MM:SS) only, without respect to time zone or DST offsets.
>>>
	param[] = {
	    type = const std::string&
	    name = otherTime
	    desc = Timestamp ("HH[:MM[:SS]]")
	}
	impl = <<<
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(otherTime, ":", timeParts);
int otherHour = 0;
int otherMinute = 0;
int otherSecond = 0;
if (timeParts.size() == 0)
    return 0;
if (timeParts.size() >= 1)
    otherHour = ::strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() >= 2)
    otherMinute = ::strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() >= 3)
    otherSecond = ::strtol(timeParts[2].c_str(), 0, 10);
>>>
	return = {
	    value = compareHMS(otherHour, otherMinute, otherSecond)
	    desc = 0 if the times of day are equal, -1 if the time of day of this object is less than, +1 if it is greater than the time of day of the argument
	}
}
function.public[] = {
    spec = virtual
    type = int
    name = compareDay
	shortDesc = Compare day
	longDesc = <<<
Compare day to that of another Datetime.
>>>
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = otherTime
	    desc = DateTime to compare this object with
	}
	impl = <<<
if ((getYear() == otherTime.getYear())
    && (getYearDay() == otherTime.getYearDay()))
    return 0;
// Different years or different days (so different days in any case).
if (getYear() < otherTime.getYear())
    return -1;
if (getYear() > otherTime.getYear())
    return 1;
// Same year, but different days.
if (getYearDay() < otherTime.getYearDay())
    return -1;
>>>
	return = {
	    value = 1
	    desc = 0 if the days are equal, -1 if the day of this object is less than, +1 if it is greater than the day of the argument
	}
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::DateTime
    name = getUTC
	shortDesc = Get UTC representation
	longDesc = <<<
Get an UTC representation of this datetime.
>>>
	impl = <<<
DateTime result;
result.setTimeTicks(getTicks());
>>>
	return = {
	    value = result
	    desc = UTC datetime
	}
}
function.public[] = {
    spec = virtual
    type = time_t
    name = getTimePosix
    const = true
	shortDesc = Get POSIX time
	longDesc = <<<
Get datetime as POSIX time, i.e. number of seconds since the beginning of the POSIX epoch.
>>>
	impl = 
	return = {
	    value = ticks - POSIX_EPOCH
	    desc = POSIX time
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getTimestamp
	shortDesc = Get timestamp
	longDesc = <<<
Get timestamp in string representation ("YYYY-MM-DD HH:MM:SS").
>>>
	impl = <<<
if (timestamp == "")
    timestamp = createTimestamp();
>>>
	return = {
	    value = timestamp
	    desc = Timestamp
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getHMS
	shortDesc = Get time of day
	longDesc = <<<
Get time of day in string representation ("HH:MM:SS").
>>>
	impl = 
	return = {
	    value = getTimestamp().substr(11, 8)
	    desc = Time of day
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getDayOfWeekName
    const = true
	shortDesc = Get day of week name
	longDesc = <<<
Get day of week name.
>>>
	impl = 
	return = {
	    value = WEEKDAY_NAME[weekDay]
	    desc = Name of day of week
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getDayOfWeekShortName
    const = true
	shortDesc = Get day of week short name
	longDesc = <<<
Get day of week short name.
>>>
	impl = 
	return = {
	    value = WEEKDAY_NAME_SHORT[weekDay]
	    desc = Short name of day of week
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getMonthName
    const = true
	shortDesc = Get month name
	longDesc = <<<
Get month name.
>>>
	impl = 
	return = {
	    value = MONTH_NAME[month - 1]
	    desc = Name of month
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getMonthShortName
    const = true
	shortDesc = Get month short name
	longDesc = <<<
Get month short name.
>>>
	impl = 
	return = {
	    value = MONTH_NAME_SHORT[month - 1]
	    desc = Short name of month
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getTimeZoneName
    const = true
	shortDesc = Get name of time zone
	longDesc = <<<
Get the short name of the time zone, including DST distinctions, if available.
>>>
	impl = <<<
if (timeZone != 0)
{
    if (!isDST())
        return timeZone->getShortNameNormal();
    else
        return timeZone->getShortNameDST();
}
>>>
	return = {
	    value = ""
	    desc = Name of time zone
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getTimeZoneAliases
    const = true
	shortDesc = Get time zone aliases
	longDesc = <<<
Get a colon (':') separated list of all recognized time zone alias names. These are the names you can use to set the time zone with setTimeZone().
>>>
	impl = <<<
std::string result;
const TimeZone* currentTimeZone;
for (unsigned int i = 0; i < defaultTimeZones.size(); i++)
{
    currentTimeZone = defaultTimeZones[i];
    if (currentTimeZone != 0)
        result.append(currentTimeZone->getAliases() + ":");
}
if (result.size() > 0);
    result.erase(result.size() - 1, 1);
>>>
	return = {
	    value = result
	    desc = Colon (':') separated list of time zone alias names
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = isDST
    const = true
	shortDesc = Get DST state
	longDesc = <<<
Get DST state.
>>>
	impl = 
	return = {
	    value = dstState
	    desc = \c true if this datetime represents DST in the current time zone, \c false otherwise
	}
}
function.public[] = {
    spec = virtual
    type = int
    name = getUTCOffset
    const = true
	shortDesc = Get UTC offset
	longDesc = <<<
Get UTC offset.
>>>
	impl = 
	return = {
	    value = utcOffset
	    desc = UTC offset, in minutes
	}
}
function.public[] = {
    spec = virtual
    type = std::string
    name = getRFCTimestamp
    const = true
	shortDesc = Get RFC 822 timestamp
	longDesc = <<<
Get RFC 822 timestamp.
>>>
	impl = <<<
std::ostringstream result;
result << getDayOfWeekShortName() << ", " << setfill('0') << setw(2)
    << getDay() << " " << getMonthShortName() << " " << getYear() << " "
    << setw(2) << getHour() << ":" << setw(2) << getMinute() << ":" 
    << setw(2) << getSecond();
string timeZoneName = getTimeZoneName();
if (timeZoneName.size() > 0)
    result << " " << timeZoneName;
else
    result << " UTC";
>>>
	return = {
	    value = result.str()
	    desc = RFC 822 timestamp
	}
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::DateTime&
    name = operator+=
	shortDesc = Add operator
	longDesc = Add time ticks to the datetime object.
	param[] = {
	    type = Ionflux::Template::TimeTicks
	    name = seconds
	    desc = time offset
	}
	impl = 
	return = {
	    value = *this
	    desc = The object itself
	}
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::DateTime&
    name = operator-=
	shortDesc = Subtract operator
	longDesc = Subtract time ticks from the datetime object.
	param[] = {
	    type = Ionflux::Template::TimeTicks
	    name = seconds
	    desc = time offset
	}
	impl = 
	return = {
	    value = *this
	    desc = The object itself
	}
}
function.public[] = {
    spec = virtual
    type = Ionflux::Template::TimeTicks
    name = operator-
    const = true
	shortDesc = Subtract operator
	longDesc = Calculate the time difference (in seconds) between datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = diffTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = 0
	    desc = Difference between datetime objects (in seconds)
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator==
    const = true
	shortDesc = Comparison operator: equal
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = false
	    desc = Result of the comparison
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator!=
    const = true
	shortDesc = Comparison operator: not equal
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = !(*this == compTime)
	    desc = Result of the comparison
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator>
    const = true
	shortDesc = Comparison operator: greater than
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = false
	    desc = Result of the comparison
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator<
    const = true
	shortDesc = Comparison operator: less than
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = false
	    desc = Result of the comparison
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator>=
    const = true
	shortDesc = Comparison operator: greater than or equal
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = false
	    desc = Result of the comparison
	}
}
function.public[] = {
    spec = virtual
    type = bool
    name = operator<=
    const = true
	shortDesc = Comparison operator: less than or equal
	longDesc = Compare datetime objects.
	param[] = {
	    type = const Ionflux::Template::DateTime&
	    name = compTime
	    desc = datetime object
	}
	impl = 
	return = {
	    value = false
	    desc = Result of the comparison
	}
}

# Pure virtual member functions.

# static member functions
function.public[] = {
    spec = static
    type = Ionflux::Template::Year
    name = countLeapYears
	shortDesc = Count leap years
	longDesc = Count the number of leap years from 0001-01-01 00:00:00 up to January 1st, 00:00:00 of the specified year.
	param[] = {
	    type = Ionflux::Template::Year
	    name = limit
	    desc = Limit for counting leap years
	}
	impl = <<<
Year result;
result = Year((limit - 1) / 4) - Year((limit - 1) / 100) 
    + Year((limit - 1) / 400);
>>>
	return = {
	    value = result
	    desc = Number of leap years up to specified year
	}
}
function.public[] = {
    spec = static
    type = bool
    name = isLeapYear
	shortDesc = Check leap year status
	longDesc = Check whether the specified year is a leap year.
	param[] = {
	    type = Ionflux::Template::Year
	    name = checkYear
	    desc = Year
	}
	impl = 
	return = {
	    value = ((checkYear % 4) == 0) && (((checkYear % 100) != 0) || ((checkYear % 400) == 0))
	    desc = \c true if specified year is a leap year, \c false otherwise
	}
}
function.public[] = {
    spec = static
    type = Ionflux::Template::DateTime
    name = getNth
	shortDesc = Get n-th occurence of a day of week in a month
	longDesc = <<<
Returns the UTC DateTime of the start (00:00:00) of the n-th occurrence of the specified day of week in the specified month of the specified year. If this day is not present in the requested month, the last occurence of that day in the specified month is returned. You can use this to get the last occurence of any day of week within a month by setting n to 5.
>>>
	param[] = {
	    type = Ionflux::Template::Year
	    name = targetYear
	    desc = Year
	}
	param[] = {
	    type = int
	    name = targetMonth
	    desc = Month (1...12)
	}
	param[] = {
	    type = int
	    name = targetWeekDay
	    desc = Day of week (0...6, where 0 = Sunday)
	}
	param[] = {
	    type = int
	    name = n
	    desc = Occurrence count of day of week in specified month (1...5)
	}
	impl = <<<
// Initialize to the first of target month.
DateTime result(targetYear, targetMonth, 1, 0, 0, 0);
// Find the first requested day of week of the month.
int weekDayOffset = targetWeekDay - result.getWeekDay();
if (weekDayOffset < 0)
    weekDayOffset += 7;
/* Find the n-th requested day of week of the month by adding full weeks 
   to the first. */
weekDayOffset += (7 * (n - 1));
result += (weekDayOffset * TICKS_1D);
// Did we overflow into the next month?
if ((result.getMonth() > targetMonth) 
    || ((result.getMonth() == 1) && (targetMonth == 12)))
{
    // Sanity check.
    if ((result.getMonth() > (targetMonth + 1)) 
        || ((result.getMonth() > 1) && (targetMonth == 12)))
        cout << "[DateTime::getNth] WARNING: Month overflow > 1 "
        "(this shouldn't happen!)." << endl;
    int rDay = result.getDay();
    /* Reset to the first day of the current month (which is the 
       requested month plus 1). */
    result -= ((rDay - 1) * TICKS_1D);
    // Find the first requested day of week of the month.
    weekDayOffset = targetWeekDay - result.getWeekDay();
    if (weekDayOffset < 0)
        weekDayOffset += 7;
    /* Find the last requested day of week of the requested month by 
       substracting a full week from the first requested day of week of 
       the current month. */
    weekDayOffset -= 7;
    result += (weekDayOffset * TICKS_1D);
}
>>>
	return = {
	    value = result
	    desc = Datetime of n-th occurence of specified day of week
	}
}
function.public[] = {
    spec = static
    type = bool
    name = isTime
	shortDesc = Check time
	longDesc = <<<
Check whether the specified string represents a time of day (i.e. has the format"HH[:MM[:SS]]"). Range checks are performed for hours, minutes and seconds.
>>>
	param[] = {
	    type = const std::string&
	    name = checkTime
	    desc = string to be checked
	}
	impl = <<<
if (checkTime.size() == 0)
    return false;
Ionflux::ObjectBase::StringVector timeParts;
Ionflux::ObjectBase::explode(checkTime, ":", timeParts);
if ((timeParts.size() < 1) || (timeParts.size() > 3))
    return false;
bool result = true;
unsigned int i = 0;
while (result && (i < timeParts.size()))
{
    if (!Ionflux::ObjectBase::isNumber(timeParts[i]))
        result = false;
    else
        i++;
}
if (!result)
    return false;
int cHour = 0;
int cMinute = 0;
int cSecond = 0;
cHour = ::strtol(timeParts[0].c_str(), 0, 10);
if (timeParts.size() > 1)
    cMinute = ::strtol(timeParts[1].c_str(), 0, 10);
if (timeParts.size() > 2)
    cSecond = ::strtol(timeParts[2].c_str(), 0, 10);
if ((cHour > 23) || (cMinute > 59) || (cSecond > 59))
    result = false;
>>>
	return = {
	    value = result
	    desc = \c true if \c checkTime represents a time of day, \c false otherwise
	}
}
function.public[] = {
    spec = static
    type = bool
    name = isDate
	shortDesc = Check date
	longDesc = <<<
Check whether the specified string represents a date (i.e. has the format "YYYY-MM-DD"). Range checks are performed for month and day, however, it is not checked whether the specified day is actually a valid date.
>>>
	param[] = {
	    type = const std::string&
	    name = checkDate
	    desc = string to be checked
	}
	impl = <<<
if (checkDate.size() == 0)
    return false;
Ionflux::ObjectBase::StringVector dateParts;
Ionflux::ObjectBase::explode(checkDate, "-", dateParts);
if (dateParts.size() != 3)
    return false;
bool result = (Ionflux::ObjectBase::isNumber(dateParts[0]) 
    && Ionflux::ObjectBase::isNumber(dateParts[1]) 
    && Ionflux::ObjectBase::isNumber(dateParts[2]));
if (!result)
    return false;
int cMonth = ::strtol(dateParts[1].c_str(), 0, 10);
int cDay = ::strtol(dateParts[2].c_str(), 0, 10);
if ((cMonth > 12) || (cDay > 31))
    result = false;
>>>
	return = {
	    value = result
	    desc = \c true if \c checkDate represents a date, \c false otherwise
	}
}
function.public[] = {
    spec = static
    type = bool
    name = isDatetime
	shortDesc = Check datetime
	longDesc = <<<
Check whether the specified string represents a datetime (i.e. has the format "YYYY-MM-DD[ HH[:MM[:SS]]]"). Range checks are performed for hours, minutes, seconds, month and day, however, it is not checked whether the specified datetime is actually a valid date.
>>>
	param[] = {
	    type = const std::string&
	    name = checkDatetime
	    desc = string to be checked
	}
	impl = <<<
if (checkDatetime.size() == 0)
    return false;
Ionflux::ObjectBase::StringVector datetimeParts;
Ionflux::ObjectBase::explode(checkDatetime, " ", datetimeParts);
if (datetimeParts.size() < 1)
    return false;
if (datetimeParts.size() == 1)
    return isDate(checkDatetime);
>>>
	return = {
	    value = (isDate(datetimeParts[0]) && isTime(datetimeParts[1]))
	    desc = \c true if \c checkDate represents a datetime, \c false otherwise
	}
}

